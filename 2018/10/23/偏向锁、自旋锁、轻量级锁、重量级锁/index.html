<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="在Java中锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁">
<meta property="og:type" content="article">
<meta property="og:title" content="偏向锁、自旋锁、轻量级锁、重量级锁">
<meta property="og:url" content="https://focusss.github.io/2018/10/23/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/index.html">
<meta property="og:site_name" content="大 湾 区 码 仔&#39;s Blog">
<meta property="og:description" content="在Java中锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://focusss.github.io/2018/10/23/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/markword.png">
<meta property="og:image" content="https://focusss.github.io/2018/10/23/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/%E5%81%8F%E5%90%91%E9%94%81%E8%8E%B7%E5%8F%96%E5%92%8C%E6%92%A4%E9%94%80%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="https://focusss.github.io/2018/10/23/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png">
<meta property="og:image" content="https://focusss.github.io/2018/10/23/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E8%86%A8%E8%83%80%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="https://focusss.github.io/2018/10/23/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81MarkWork%E5%A4%8D%E5%88%B6.png">
<meta property="og:image" content="https://focusss.github.io/2018/10/23/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%AE%9A.png">
<meta property="og:image" content="https://focusss.github.io/2018/10/23/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/%E5%AF%B9%E8%B1%A1%E7%9B%91%E8%A7%86%E5%99%A8.png">
<meta property="article:published_time" content="2018-10-23T12:25:33.000Z">
<meta property="article:modified_time" content="2021-12-11T17:19:14.163Z">
<meta property="article:author" content="大湾区码仔驰名商标">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="锁机制">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://focusss.github.io/2018/10/23/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/markword.png"><title>偏向锁、自旋锁、轻量级锁、重量级锁 | 大 湾 区 码 仔's Blog</title><link ref="canonical" href="https://focusss.github.io/2018/10/23/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">大 湾 区 码 仔's Blog</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">偏向锁、自旋锁、轻量级锁、重量级锁</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2018-10-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-12-12</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h2 id="线程阻塞">
          <a href="#线程阻塞" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h2>
      <p>操作系统在唤醒或阻塞一个线程的时候，需要在用户态和核心态之间切换，这种切换会消耗大量的系统资源。因为在用户态和核心态都有各自专用的内存空间、寄存器等。用户态切换到核心态需要传递许多变量、参数给内核，内核也需要保存用户态在切换时的一些寄存器值、变量等，以便核心态调用结束后切换回用户态继续工作。</p>

        <h2 id="Java对象头">
          <a href="#Java对象头" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2>
      <p>锁存在Java对象头。如果对象是数组类型，则虚拟机用3个word（字宽）存储对象头，如果对象是非数组类型，则用2个字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。对象头的结构如下：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>长度</th>
<th align="right">内容</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>32/64bit</td>
<td align="right">Mark Word</td>
<td align="center">存储对象的hashCode或锁信息等</td>
</tr>
<tr>
<td>32/64bit</td>
<td align="right">Class Metadata Address</td>
<td align="center">存储到对象类型数据的指针</td>
</tr>
<tr>
<td>32/64bit</td>
<td align="right">Array length</td>
<td align="center">组的长度（如果当前对象是数组）</td>
</tr>
</tbody></table></div>
<p>在Java对象头中，与锁相关的结构就是Mark Word了。默认存储了对象的hashcode、分代年龄<br>锁标记位。32位JVM的Mark Word的默认存储结构如下：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>锁状态</th>
<th align="right">25 bit</th>
<th align="right">4bit</th>
<th align="right">1bit（是否位偏向锁）</th>
<th align="center">2bit（锁标志位）</th>
</tr>
</thead>
<tbody><tr>
<td>无锁状态</td>
<td align="right">对象的hashCode</td>
<td align="right">对象分代年龄</td>
<td align="right">0</td>
<td align="center">01</td>
</tr>
</tbody></table></div>
<p>最后2bit是锁状态标志位，用来标记当前对象的状态，对象的所处的状态，决定了Mark Word存储的内容。标志位的情况大致如下：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>状态</th>
<th align="right">标志位</th>
<th align="center">存储内容</th>
</tr>
</thead>
<tbody><tr>
<td>未锁定</td>
<td align="right">01</td>
<td align="center">对象哈希码、对象分代年龄</td>
</tr>
<tr>
<td>轻量级锁定</td>
<td align="right">00</td>
<td align="center">指向锁记录的指针</td>
</tr>
<tr>
<td>膨胀(重量级锁定)</td>
<td align="right">10</td>
<td align="center">执行重量级锁定的指针</td>
</tr>
<tr>
<td>GC标记</td>
<td align="right">11</td>
<td align="center">空(不需要记录信息)</td>
</tr>
<tr>
<td>可偏向</td>
<td align="right">01</td>
<td align="center">偏向线程ID、偏向时间戳、对象分代年龄</td>
</tr>
<tr>
<td>在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化，32位虚拟机在不同状态下Mark Word结构如下图所示：</td>
<td align="right"></td>
<td align="center"></td>
</tr>
<tr>
<td>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="markword.png" alt="markword">
      </td>
<td align="right"></td>
<td align="center"></td>
</tr>
</tbody></table></div>

        <h2 id="锁种类">
          <a href="#锁种类" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁种类" class="headerlink" title="锁种类"></a>锁种类</h2>
      <p>synchronized是重量级锁，会导致争用不到锁的线程进入阻塞状态，是悲观锁的一种。java默认开启了自旋锁，它和轻量级锁、偏向锁一样都是乐观锁。在Java中锁一共有四种状态：<strong>无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态</strong>。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。下面来看几种锁机制。 </p>

        <h3 id="自旋锁">
          <a href="#自旋锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3>
      <p>线程的阻塞和唤醒需要从用户态转为核心态，频繁的阻塞和唤醒对CPU来说一件负担很重的工作。很多对象的锁定状态只会持续很短的一段时间，在很短的时间内阻塞并唤醒线程显然是不值得。因此，可以利用自旋锁。让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于<strong>running状态</strong>，但是基于JVM线程调度，会让出时间片，所以其他线程依旧有申请锁和释放锁的机会。<br>如果持有锁的线程执行的时间超过自旋等待的最大时间（默认自旋10次）仍没有释放锁，就会导致其它竞争锁的线程在最大等待时间内还是获取不到锁，这时竞争线程会停止自旋进入阻塞状态。<br>JDK6引入自适应的自旋锁：自旋时间不固定，由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机会认为这次自旋很有可能再次成功，进而允许更长的自旋等待时间。</p>

        <h4 id="优缺点">
          <a href="#优缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4>
      <p>对于锁竞争不激烈且占用锁时间非常短的场景，自旋锁可以尽可能地减少线程的阻塞。但如果锁竞争激烈或者持有锁的线程需要长时间占用锁，这时候就不适合使用自旋锁。因为自旋锁在获取锁前一直都占用CPU，同时还有大量线程在竞争一个锁，导致获取锁的时间很长。自旋的消耗大于线程阻塞挂起的消耗。</p>

        <h4 id="设置">
          <a href="#设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#设置" class="headerlink" title="设置"></a>设置</h4>
      <p>在JDK6中，Java虚拟机提供<code>-XX:+UseSpinning</code>参数来开启自旋锁，使用<code>-XX:PreBlockSpin</code>参数来设置自旋锁等待的次数。<br>在JDK7开始，自旋锁的参数被取消，虚拟机不再支持由用户配置自旋锁，自旋锁总是会执行，自旋锁次数也由虚拟机自动调整。</p>

        <h3 id="偏向锁">
          <a href="#偏向锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3>
      <p>如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。<br>偏向锁会偏向于第一个获得它的线程（Mark Word中的偏向线程ID信息），如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E5%81%8F%E5%90%91%E9%94%81%E8%8E%B7%E5%8F%96%E5%92%8C%E6%92%A4%E9%94%80%E8%BF%87%E7%A8%8B.png" alt="偏向锁获取和撤销">
      </p>

        <h4 id="偏向锁的获取">
          <a href="#偏向锁的获取" class="heading-link"><i class="fas fa-link"></i></a><a href="#偏向锁的获取" class="headerlink" title="偏向锁的获取"></a>偏向锁的获取</h4>
      <p>当锁对象第一次被线程获取的时候，虚拟机会把对象头中的标志位设为<strong>01</strong>，即偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象头的Mark Work之中。</p>

        <h4 id="偏向锁的撤销">
          <a href="#偏向锁的撤销" class="heading-link"><i class="fas fa-link"></i></a><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4>
      <p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，<strong>线程不会主动释放偏向锁</strong>。偏向锁的撤销，需要等待全局安全点（在这个时间点没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断对象是否处于被锁定的状态撤销偏向锁后恢复到未锁定（标志位为<strong>01</strong>）或轻量级锁（标志位为<strong>00</strong>）的状态。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="偏向锁、轻量级锁状态转换">
      </p>

        <h4 id="偏向锁的设置">
          <a href="#偏向锁的设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#偏向锁的设置" class="headerlink" title="偏向锁的设置"></a>偏向锁的设置</h4>
      <p>偏向锁在JDK6 和JDK 7中默认时开启的，它会在应用程序启动几秒后激活，可以使用<code>-XX：BiasedLockingStartupDelay=0</code>来关闭延迟。如果应用程序中所有的锁通常处于竞争状态情况下，可以使用<code>-XX:-UseBiasedLocking=false</code>来关闭偏向锁，那么所有的锁一开始默认会进入轻量级锁状态。</p>

        <h4 id="适用场景">
          <a href="#适用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4>
      <p>始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作； 在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向锁的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用。</p>

        <h3 id="轻量级锁">
          <a href="#轻量级锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3>
      <p>由偏向锁升级而来，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁竞争的时候，偏向锁就会升级为轻量级锁。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E8%86%A8%E8%83%80%E8%BF%87%E7%A8%8B.png" alt="轻量级锁膨胀">
      </p>

        <h4 id="加锁过程">
          <a href="#加锁过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h4>
      <p>在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为<strong>01</strong>状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word拷贝（官方名为Displaced Mark Word），这时候线程堆栈与对象头的状态如下图所示。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81MarkWork%E5%A4%8D%E5%88%B6.png" alt="轻量级锁MarkWork复制">
      <br>然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位转变为<strong>00</strong>，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如下图所示。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%AE%9A.png" alt="轻量级锁定">
      <br>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧。如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。<strong>如果有两个以上的线程争用同一个锁，那么轻量级锁就不再有效，要升级为重量级锁，锁标志的状态值变为10，Mark Word中存储的就是指向重量级（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</strong> 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</p>

        <h4 id="解锁过程">
          <a href="#解锁过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h4>
      <p>解锁过程也是通过CAS操作来进行的，如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。</p>

        <h3 id="重量级锁">
          <a href="#重量级锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3>
      <p>如果线程尝试获取锁的时候，轻量级锁正被其他线程占有，那么它就会修改Mark Word,升级为重量级锁。重量锁在JVM中又叫对象监视器（Monitor）。</p>
<blockquote>
<p>JVM基于进入和退出monitor对象来实现方法同步和代码块同步的。代码块同步是使用<strong>monitorenter</strong>和<strong>monitorexit</strong>指令实现，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明，但是方法的同步同样可以使用这两个指令来实现。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处， JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个 monitor 与之关联，当且一个monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。</p>
</blockquote>
<p>当多个线程同时请求某个对象监视器时，对象监视器会设置几种状态用来区分请求的线程：</p>
<ul>
<li><p>Contention List：一个先进先出（FIFO）的队列，所有请求锁的线程将被首先放置到该竞争队列。每次新加入Node时都会在队头进行，而取得操作则发生在队尾。</p>
</li>
<li><p>Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List</p>
</li>
<li><p>Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set</p>
</li>
<li><p>OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck</p>
</li>
<li><p>Owner：获得锁的线程称为Owner</p>
</li>
<li><p>!Owner：释放锁的线程</p>
</li>
</ul>
<p>下图反映了个状态转换关系：</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E5%AF%B9%E8%B1%A1%E7%9B%91%E8%A7%86%E5%99%A8.png" alt="对象监视器">
      <br>JVM每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList会被大量的并发线程进行CAS访问。为了降低对尾部元素的竞争，JVM会将一部分线程移动到EntryList中作为候选竞争线程。Owner线程会在unlock时，将ContentList中的部分线程迁移到EntryList中，并指定EntryList中的某个线程为OnDeck线程（一般时最先进去的那个线程）。Owner线程并不直接把锁传递给OnDeck线程，而是把锁竞争的权利交给OnDeck，OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM中，也把这种选择行为称为“竞争切换”。<br>OnDeck线程获取锁资源后，会变为Owner线程，而没有得到锁资源的仍然停留在EntryList中。如果Owner线程被wait方法阻塞，则转移到WaitSet队列中，直到某个时刻通过notify或者notifyAll唤醒，会重新进去EntryList中。处于ContentionList、EntryList、WaitSet中的线程都处于阻塞状态，该阻塞是由操作系统来完成的。</p>

        <h4 id="Synchronized">
          <a href="#Synchronized" class="heading-link"><i class="fas fa-link"></i></a><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4>
      <p>它可以把任意一个非NULL的对象当作锁：</p>
<ul>
<li>作用于方法时，锁住的是对象的实例</li>
<li>当作用于静态方法时，锁住的是Class对象，相当于类的一个全局锁。会锁住所有调用该方法的线程</li>
<li>作用于一个对象实例时，锁住的是所有以该对象为锁的代码块</li>
</ul>
<p>Synchronized是非公平锁。Synchronized在线程进入ContentList时，等待的线程会先尝试自旋获取锁，如果获取不到就进入ContentionList，这明显对于已经进入队列的线程是不公平的，还有就是自旋获取锁的线程还有可能直接抢占OnDeck线程的锁资源。</p>

        <h4 id="Synchronized执行过程">
          <a href="#Synchronized执行过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#Synchronized执行过程" class="headerlink" title="Synchronized执行过程"></a>Synchronized执行过程</h4>
      <ul>
<li>检测Mark Word里面是不是当前线程的ID。如果是，表示当前线程处于偏向锁；如果不是，则使用CAS将当前线程的ID替换Mark Word。替换成功则表示当前线程获得偏向锁，设置锁状态标志位为<strong>01</strong>；失败则说明发生竞争，撤销偏向锁，升级为轻量级锁。</li>
<li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针。如果成功，当前线程获得锁；如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。如果自旋成功，则依然处于轻量级状态，如果自旋失败，则升级为重量级锁。另外，等待轻量级锁的线程不会阻塞，它会一直自旋等待锁。</li>
</ul>

        <h4 id="Synchronized与volatile区别">
          <a href="#Synchronized与volatile区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#Synchronized与volatile区别" class="headerlink" title="Synchronized与volatile区别"></a>Synchronized与volatile区别</h4>
      <p>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的<br>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性<br>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。<br>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p>

        <h2 id="锁的优化策略">
          <a href="#锁的优化策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁的优化策略" class="headerlink" title="锁的优化策略"></a>锁的优化策略</h2>
      <ul>
<li>减少锁持有时间 <br>         例如：对一个方法加锁，不如对方法中需要同步的几行代码加锁。</li>
<li>减小锁粒度<br>        例如：ConcurrentHashMap采取对segment加锁而不是整个map加锁，提高并发性。</li>
<li>锁分离 <br>        根据同步操作的性质，把锁划分为的读锁和写锁，读锁之间不互斥，提高了并发性。</li>
<li>锁粗化 <br>        针对一个线程中来说，只有个别地方需要同步，所以把锁加在同步的语句上而不是更大的范围，<pre><code>  减少线程持有锁的时间；假如在一个循环里面，重复使用synchronized关键字。需要频繁地获
  取锁、释放锁。要知道锁的取得（假如只考虑重量级MutexLock）是需要操作系统调用的，从用
  户态进入内核态，开销很大。于是针对这种情况也许虚拟机发现了之后会适当扩大加锁的范围
  （所以叫锁粗化）以避免频繁的拿锁释放锁的过程。 
</code></pre>
</li>
<li>锁消除 <br>        锁消除是编译器做的事，根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出<pre><code>  当前线程（即不会影响线程空间外的数据），那么可以认为这段代码是线程安全的，虚拟机会
  直接去掉这个锁。
</code></pre>
</li>
</ul>

        <h2 id="总结">
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
      <blockquote>
<ul>
<li>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</li>
</ul>
</blockquote>
<p>在所有的锁都启用的情况下线程进入临界区时会先去获取偏向锁，如果已经存在偏向锁了，则会尝试使用CAS操作获取轻量级锁，启用自旋锁，如果自旋也没有获取到锁，则使用重量级锁，没有获取到锁的线程阻塞挂起，直到持有锁的线程执行完同步块唤醒他们。<br>偏向锁是在无锁争用的情况下使用的，也就是同步开在当前线程没有执行完之前，没有其它线程会执行该同步块。如果仍然是同个线程去获得这个锁，尝试偏向锁时会直接进入同步块，不需要再次获得锁。一旦有了第二个线程的争用，偏向锁就会升级为轻量级锁，如果轻量级锁自旋到达阈值后，没有获取到锁，就会升级为重量级锁。</p>

        <h3 id="优缺点-1">
          <a href="#优缺点-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th>锁</th>
<th align="right">优点</th>
<th align="right">缺点</th>
<th align="right">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td align="right">加锁和解锁不需要额外的消耗，与执行非同步方法相比仅存在纳秒级的差距</td>
<td align="right">如果线程存在锁竞争，会带来额外的锁撤销的消耗</td>
<td align="right">适用于只有一个线程访问同步块的场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td align="right">竞争的线程不会阻塞，提高了程序的响应速度</td>
<td align="right">如果始终得不到锁竞争的线程会使用自旋消耗CPU</td>
<td align="right">追求响应时间，锁占用时间很短</td>
</tr>
<tr>
<td>重量级锁</td>
<td align="right">线程竞争不使用自旋，不会消耗CPU</td>
<td align="right">线程阻塞，响应时间缓慢</td>
<td align="right">追求吞吐量，锁占用时间较长</td>
</tr>
</tbody></table></div>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://focusss.github.io">大湾区码仔驰名商标</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://focusss.github.io/2018/10/23/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/">https://focusss.github.io/2018/10/23/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://focusss.github.io/tags/JVM/">JVM</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://focusss.github.io/tags/%E9%94%81%E6%9C%BA%E5%88%B6/">锁机制</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2019/02/05/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%8C%BA%E5%88%AB/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">方法区和永久代区别</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2018/10/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Callable%E4%B8%8ERunnable/"><span class="paginator-prev__text">Java并发编程-Callable与Runnable</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E"><span class="toc-number">1.</span> <span class="toc-text">
          线程阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">2.</span> <span class="toc-text">
          Java对象头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%A7%8D%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">
          锁种类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">3.1.</span> <span class="toc-text">
          自旋锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.1.1.</span> <span class="toc-text">
          优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.1.2.</span> <span class="toc-text">
          设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">3.2.</span> <span class="toc-text">
          偏向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">3.2.1.</span> <span class="toc-text">
          偏向锁的获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80"><span class="toc-number">3.2.2.</span> <span class="toc-text">
          偏向锁的撤销</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.2.3.</span> <span class="toc-text">
          偏向锁的设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.4.</span> <span class="toc-text">
          适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">3.3.</span> <span class="toc-text">
          轻量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">
          加锁过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text">
          解锁过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">3.4.</span> <span class="toc-text">
          重量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized"><span class="toc-number">3.4.1.</span> <span class="toc-text">
          Synchronized</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.4.2.</span> <span class="toc-text">
          Synchronized执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized%E4%B8%8Evolatile%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.3.</span> <span class="toc-text">
          Synchronized与volatile区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">4.</span> <span class="toc-text">
          锁的优化策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">
          总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">5.1.</span> <span class="toc-text">
          优缺点</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/headImg.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">平安大赚 财丁兴旺</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">86</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">24</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">34</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>大湾区码仔驰名商标</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>