<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="MySQL中有六种日志文件，分别是：重做日志（redo log）、回滚日志（undo log）、二进制日志（binlog）、错误日志（errorlog）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log）。">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL 中的重做日志，回滚日志 ，以及二进制日志的简单总结">
<meta property="og:url" content="https://focusss.github.io/2019/03/29/MySQL-%E4%B8%AD%E7%9A%84%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%8C%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97-%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="大 湾 区 码 仔&#39;s Blog">
<meta property="og:description" content="MySQL中有六种日志文件，分别是：重做日志（redo log）、回滚日志（undo log）、二进制日志（binlog）、错误日志（errorlog）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log）。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://focusss.github.io/2019/03/29/MySQL-%E4%B8%AD%E7%9A%84%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%8C%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97-%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/innodb_log_buffer.jpg">
<meta property="og:image" content="https://focusss.github.io/2019/03/29/MySQL-%E4%B8%AD%E7%9A%84%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%8C%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97-%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/undo_log.jpg">
<meta property="og:image" content="https://focusss.github.io/2019/03/29/MySQL-%E4%B8%AD%E7%9A%84%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%8C%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97-%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/binlog1.jpg">
<meta property="og:image" content="https://focusss.github.io/2019/03/29/MySQL-%E4%B8%AD%E7%9A%84%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%8C%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97-%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/binlog2.jpg">
<meta property="og:image" content="https://focusss.github.io/2019/03/29/MySQL-%E4%B8%AD%E7%9A%84%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%8C%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97-%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/%E4%BA%8B%E5%8A%A1.png">
<meta property="article:published_time" content="2019-03-29T04:10:50.000Z">
<meta property="article:modified_time" content="2021-12-11T11:11:47.414Z">
<meta property="article:author" content="大湾区码仔驰名商标">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://focusss.github.io/2019/03/29/MySQL-%E4%B8%AD%E7%9A%84%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%8C%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97-%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/innodb_log_buffer.jpg"><title>MySQL 中的重做日志，回滚日志 ，以及二进制日志的简单总结 | 大 湾 区 码 仔's Blog</title><link ref="canonical" href="https://focusss.github.io/2019/03/29/MySQL-%E4%B8%AD%E7%9A%84%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%8C%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97-%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">大 湾 区 码 仔's Blog</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">MySQL 中的重做日志，回滚日志 ，以及二进制日志的简单总结</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-03-29</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-12-11</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h3 id="简介">
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h3>
      <p>MySQL中有六种日志文件，分别是：重做日志（redo log）、回滚日志（undo log）、二进制日志（binlog）、错误日志（errorlog）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log）。<br>其中重做日志和回滚日志与事务操作息息相关，二进制日志也与事务操作有一定的关系，这三种日志，对理解MySQL中的事务操作有着重要的意义。<br>innodb事务日志包括redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。<br>undo log不是redo log的逆向过程，其实它们都算是用来恢复的日志：<br>1.redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。<br>2.undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。</p>

        <h3 id="前滚和回滚">
          <a href="#前滚和回滚" class="heading-link"><i class="fas fa-link"></i></a><a href="#前滚和回滚" class="headerlink" title="前滚和回滚"></a>前滚和回滚</h3>
      
        <h4 id="前滚">
          <a href="#前滚" class="heading-link"><i class="fas fa-link"></i></a><a href="#前滚" class="headerlink" title="前滚"></a>前滚</h4>
      <p>   未完全提交的事务，即该事务已经被执行commit命令了，只是现在该事务修改所对应的脏数据块中只有一部分被写到磁盘上的数据文件中，还有一部分已经被置为提交标记的脏块还在内存上，如果此时数据库实例崩溃了，则当数据库实例恢复时，就需要用前滚（这个机制）来完成事务的完全提交，即将先前那部分已经被置为提交标记且还在内存上的脏块写入到磁盘上的数据文件中。</p>

        <h4 id="回滚">
          <a href="#回滚" class="heading-link"><i class="fas fa-link"></i></a><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4>
      <p>    未提交的事务，即该事务未被执行commit命令。但是此时，该事务修改的脏块中也有可能一部分脏块写入到数据文件中了。如果此时数据库实例崩溃了，则当数据库实例恢复时，就需要用回滚（这个机制）来将先前那部分已经写入到数据文件的脏块从数据文件上撤销掉。</p>

        <h3 id="重做日志（redo-log）">
          <a href="#重做日志（redo-log）" class="heading-link"><i class="fas fa-link"></i></a><a href="#重做日志（redo-log）" class="headerlink" title="重做日志（redo log）"></a>重做日志（redo log）</h3>
      <p>redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。</p>

        <h4 id="作用">
          <a href="#作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#作用" class="headerlink" title="作用"></a>作用</h4>
      <ul>
<li>确保事务的持久性。</li>
<li>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</li>
</ul>

        <h4 id="内容">
          <a href="#内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#内容" class="headerlink" title="内容"></a>内容</h4>
      <p>物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。</p>

        <h4 id="什么时候产生">
          <a href="#什么时候产生" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么时候产生" class="headerlink" title="什么时候产生"></a>什么时候产生</h4>
      <p>事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。</p>

        <h4 id="什么时候释放">
          <a href="#什么时候释放" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么时候释放" class="headerlink" title="什么时候释放"></a>什么时候释放</h4>
      <p>当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p>

        <h4 id="对应的物理文件">
          <a href="#对应的物理文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#对应的物理文件" class="headerlink" title="对应的物理文件"></a>对应的物理文件</h4>
      <p>默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&amp;ib_logfile2。</p>
<ul>
<li>innodb_log_group_home_dir：指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。</li>
<li>innodb_log_files_in_group：指定重做日志文件组中文件的数量，默认2<br>关于文件的大小和数量，由一下两个参数配置</li>
<li>innodb_log_file_size：重做日志文件的大小。</li>
<li>innodb_mirrored_log_groups：指定了日志镜像文件组的数量，默认1</li>
</ul>

        <h4 id="redo-log是什么时候写盘的？">
          <a href="#redo-log是什么时候写盘的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#redo-log是什么时候写盘的？" class="headerlink" title="redo log是什么时候写盘的？"></a>redo log是什么时候写盘的？</h4>
      <p>前面说了是在事物开始之后逐步写盘的。<br>之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，<br>原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="innodb_log_buffer.jpg">
      </p>
<p>然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘<br>1，Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。<br>2，每个事务提交时会将重做日志刷新到重做日志文件。<br>3，当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件<br>由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，Innodb_log_buffer到重做日志文件是Master Thread线程的定时任务。<br>因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。<br>即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。<br>这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（commit）的时间也是很短暂的。</p>

        <h4 id="参数设置">
          <a href="#参数设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4>
      <p>MySQL支持用户自定义在commit时如何将log buffer中的日志刷log file中。这种控制通过变量 innodb_flush_log_at_trx_commit 的值来决定。该变量有3种值：0、1、2，默认为1。但注意，这个变量只是控制commit动作是否刷新log buffer到磁盘。</p>
<ul>
<li>当设置为1的时候，事务每次提交都会将log buffer中的日志写入os buffer并调用fsync()刷到log file on disk中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能较差。</li>
<li>当设置为0的时候，事务提交时不会将log buffer中日志写入到os buffer，而是每秒写入os buffer并调用fsync()写入到log file on disk中。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。</li>
<li>当设置为2的时候，每次提交都仅写入到os buffer，然后是每秒调用fsync()将os buffer中的日志写入到log file on disk。</li>
</ul>
<p>在主从复制结构中，要保证事务的持久性和一致性，需要对日志相关变量设置为如下：</p>
<ul>
<li>如果启用了二进制日志，则设置sync_binlog=1，即每提交一次事务同步写到磁盘中。</li>
<li>总是设置innodb_flush_log_at_trx_commit=1，即每提交一次事务都写到磁盘中。<br>上述两项变量的设置保证了：每次提交事务都写入二进制日志和事务日志，并在提交时将它们刷新到磁盘中。</li>
</ul>
<ul>
<li>innodb_flush_log_at_trx_commit={0|1|2} # 指定何时将事务日志刷到磁盘，默认为1。<br>0表示每秒将”log buffer”同步到”os buffer”且从”os buffer”刷到磁盘日志文件中。<br>1表示每事务提交都将”log buffer”同步到”os buffer”且从”os buffer”刷到磁盘日志文件中。<br>2表示每事务提交都将”log buffer”同步到”os buffer”但每秒才从”os buffer”刷到磁盘日志文件中。</li>
<li>innodb_log_buffer_size：# log buffer的大小，默认8M</li>
<li>innodb_log_file_size：#事务日志的大小，默认5M</li>
<li>innodb_log_files_group =2：# 事务日志组中的事务日志文件个数，默认2个</li>
<li>innodb_log_group_home_dir =./：# 事务日志组路径，当前目录表示数据目录</li>
<li>innodb_mirrored_log_groups =1：# 指定事务日志组的镜像组个数，但镜像功能好像是强制关闭的，所以只有一个log group。在MySQL5.7中该变量已经移除。</li>
</ul>

        <h3 id="回滚日志（undo-log）">
          <a href="#回滚日志（undo-log）" class="heading-link"><i class="fas fa-link"></i></a><a href="#回滚日志（undo-log）" class="headerlink" title="回滚日志（undo log）"></a>回滚日志（undo log）</h3>
      
        <h4 id="作用-1">
          <a href="#作用-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4>
      <p>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</p>
<p>在数据修改的时候，不仅记录了redo，还记录了相对应的undo，如果因为某些原因导致事务失败或回滚了，可以借助该undo进行回滚。</p>
<p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</p>
<p>当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。</p>
<p>undo log是采用段(segment)的方式来记录的，每个undo操作在记录的时候占用一个undo log segment。</p>
<p>另外，undo log也会产生redo log，因为undo log也要实现持久性保护。</p>

        <h4 id="内容-1">
          <a href="#内容-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#内容-1" class="headerlink" title="内容"></a>内容</h4>
      <p>逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。</p>

        <h4 id="什么时候产生-1">
          <a href="#什么时候产生-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么时候产生-1" class="headerlink" title="什么时候产生"></a>什么时候产生</h4>
      <p>事务开始之前，将当前的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性</p>

        <h4 id="什么时候释放-1">
          <a href="#什么时候释放-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么时候释放-1" class="headerlink" title="什么时候释放"></a>什么时候释放</h4>
      <p>当事务提交之后，undo log并不能立马被删除，<br>而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</p>

        <h4 id="对应的物理文件-1">
          <a href="#对应的物理文件-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#对应的物理文件-1" class="headerlink" title="对应的物理文件"></a>对应的物理文件</h4>
      <p>MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。<br>MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数<br>如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。<br>关于MySQL5.7之后的独立undo 表空间配置参数如下<br>innodb_undo_directory = /data/undospace/ –undo独立表空间的存放目录<br>innodb_undo_logs = 128 –回滚段为128KB<br>innodb_undo_tablespaces = 4 –指定有4个undo log文件</p>
<p>如果undo使用的共享表空间，这个共享表空间中又不仅仅是存储了undo的信息，共享表空间的默认为与MySQL的数据目录下面，其属性由参数innodb_data_file_path配置。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="undo_log.jpg">
      </p>

        <h4 id="其他">
          <a href="#其他" class="heading-link"><i class="fas fa-link"></i></a><a href="#其他" class="headerlink" title="其他"></a>其他</h4>
      <p>undo是在事务开始之前保存的被修改数据的一个版本，产生undo日志的时候，同样会伴随类似于保护事务持久化机制的redo log的产生。<br>默认情况下undo文件是保持在共享表空间的，也即ibdatafile文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在共享表空间中的。<br>因此共享表空间可能会变的很大，默认情况下，也就是undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的。<br>因此，mysql5.7之后的“独立undo 表空间”的配置就显得很有必要了。</p>

        <h4 id="delete-update操作的内部机制">
          <a href="#delete-update操作的内部机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#delete-update操作的内部机制" class="headerlink" title="delete/update操作的内部机制"></a>delete/update操作的内部机制</h4>
      <p>当事务提交的时候，innodb不会立即删除undo log，因为后续还可能会用到undo log，如隔离级别为repeatable read时，事务读取的都是开启事务时的最新提交行版本，只要该事务不结束，该行版本就不能删除，即undo log不能删除。</p>
<p>但是在事务提交的时候，会将该事务对应的undo log放入到删除列表中，未来通过purge来删除。并且提交事务时，还会判断undo log分配的页是否可以重用，如果可以重用，则会分配给后面来的事务，避免为每个独立的事务分配独立的undo log页而浪费存储空间和性能。</p>
<p>通过undo log记录delete和update操作的结果发现：(insert操作无需分析，就是插入行而已)</p>
<ul>
<li>delete操作实际上不会直接删除，而是将delete对象打上delete flag，标记为删除，最终的删除操作是purge线程完成的。</li>
<li>update分为两种情况：update的列是否是主键列。<br>如果不是主键列，在undo log中直接反向记录是如何update的。即update是直接进行的。<br>如果是主键列，update分两部执行：先删除该行，再插入一行目标行。</li>
</ul>

        <h3 id="二进制日志（binlog）">
          <a href="#二进制日志（binlog）" class="heading-link"><i class="fas fa-link"></i></a><a href="#二进制日志（binlog）" class="headerlink" title="二进制日志（binlog）"></a>二进制日志（binlog）</h3>
      
        <h4 id="作用-2">
          <a href="#作用-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4>
      <ul>
<li>用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。</li>
<li>用于数据库的基于时间点的还原。</li>
</ul>

        <h4 id="内容-2">
          <a href="#内容-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#内容-2" class="headerlink" title="内容"></a>内容</h4>
      <p>逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。<br>但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）反向的信息，<br>也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。<br>在使用mysql binlog解析binlog之后一些都会真相大白。<br>因此可以基于binlog做到类似于oracle的闪回功能，其实都是依赖于binlog中的日志记录。</p>

        <h4 id="什么时候产生-2">
          <a href="#什么时候产生-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么时候产生-2" class="headerlink" title="什么时候产生"></a>什么时候产生</h4>
      <p>事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。<br>这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。<br>因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。<br>这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。</p>

        <h4 id="什么时候释放-2">
          <a href="#什么时候释放-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么时候释放-2" class="headerlink" title="什么时候释放"></a>什么时候释放</h4>
      <p>binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="binlog1.jpg">
      <br>对应的物理文件：<br>配置文件的路径为log_bin_basename，binlog日志文件按照指定大小，当日志文件达到指定的最大的大小之后，进行滚动更新，生成新的日志文件。<br>对于每个binlog日志文件，通过一个统一的index文件来组织。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="binlog2.jpg">
      </p>

        <h4 id="其他-1">
          <a href="#其他-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4>
      <p>二进制日志的作用之一是还原数据库的，这与redo log很类似，也记录了innodb表的很多操作，也能实现重做的功能，但是两者有本质的不同</p>
<ul>
<li><p>作用不同：redo log是保证事务的持久性的，是事务层面的，binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。</p>
</li>
<li><p>内容不同：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是sql语句</p>
</li>
<li><p>两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。</p>
</li>
<li><p>恢复数据时候的效率，基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog</p>
</li>
<li><p>二进制日志是在存储引擎的上层产生的，不管是什么存储引擎，对数据库进行了修改都会产生二进制日志。而redo log是innodb层产生的，只记录该存储引擎中表的修改。并且二进制日志先于redo log被记录</p>
</li>
<li><p>二进制日志只在每次事务提交的时候一次性写入缓存中的日志”文件”。而redo log在数据准备修改前写入缓存中的redo log中，然后才对缓存中的数据执行修改操作；而且保证在发出事务提交指令时，先向缓存中的redo log写入日志，写入完成后才执行提交动作</p>
</li>
</ul>
<p>关于事务提交时，redo log和binlog的写入顺序，为了保证主从复制时候的主从一致（当然也包括使用binlog进行基于时间点还原的情况），是要严格一致的，<br>MySQL通过两阶段提交过程来完成事务的一致性的，也即redo log和binlog的一致性的，理论上是先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。</p>

        <h3 id="日志刷盘的规则">
          <a href="#日志刷盘的规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#日志刷盘的规则" class="headerlink" title="日志刷盘的规则"></a>日志刷盘的规则</h3>
      <p>log buffer中未刷到磁盘的日志称为脏日志(dirty log)。</p>
<p>在上面的说过，默认情况下事务每次提交的时候都会刷事务日志到磁盘中，这是因为变量 innodb_flush_log_at_trx_commit 的值为1。但是innodb不仅仅只会在有commit动作后才会刷日志到磁盘，这只是innodb存储引擎刷日志的规则之一。</p>
<p>刷日志到磁盘有以下几种规则：</p>
<p>1.发出commit动作时。已经说明过，commit发出后是否刷日志由变量 innodb_flush_log_at_trx_commit 控制。</p>
<p>2.每秒刷一次。这个刷日志的频率由变量 innodb_flush_log_at_timeout 值决定，默认是1秒。要注意，这个刷日志频率和commit动作无关。</p>
<p>3.当log buffer中已经使用的内存超过一半时。</p>
<p>4.当有checkpoint时，checkpoint在一定程度上代表了刷到磁盘时日志所处的LSN位置。</p>

        <h3 id="数据页刷盘的规则及checkpoint">
          <a href="#数据页刷盘的规则及checkpoint" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据页刷盘的规则及checkpoint" class="headerlink" title="数据页刷盘的规则及checkpoint"></a>数据页刷盘的规则及checkpoint</h3>
      <p>内存中(buffer pool)未刷到磁盘的数据称为脏数据(dirty data)。由于数据和日志都以页的形式存在，所以脏页表示脏数据和脏日志。<br>不仅仅是日志需要刷盘，脏数据页也一样需要刷盘。</p>
<p>在innodb中，数据刷盘的规则只有一个：checkpoint。但是触发checkpoint的情况却有几种。不管怎样，checkpoint触发后，会将buffer中脏数据页和脏日志页都刷到磁盘。</p>
<p>innodb存储引擎中checkpoint分为两种：</p>
<ul>
<li>sharp checkpoint：在重用redo log文件(例如切换日志文件)的时候，将所有已记录到redo log中对应的脏数据刷到磁盘。</li>
<li>fuzzy checkpoint：一次只刷一小部分的日志到磁盘，而非将所有脏日志刷盘。有以下几种情况会触发该检查点：<br> 1、 master thread checkpoint：由master线程控制，每秒或每10秒刷入一定比例的脏页到磁盘。<br> 2、flush_lru_list checkpoint：从MySQL5.6开始可通过 innodb_page_cleaners 变量指定专门负责脏页刷盘的page cleaner线程的个数，该线程的目的是为了保证lru列表有可用的空闲页。<br> 3、async/sync flush checkpoint：同步刷盘还是异步刷盘。例如还有非常多的脏页没刷到磁盘(非常多是多少，有比例控制)，这时候会选择同步刷到磁盘，但这很少出现；如果脏页不是很多，可以选择异步刷到磁盘，如果脏页很少，可以暂时不刷脏页到磁盘<br> 4、dirty page too much checkpoint：脏页太多时强制触发检查点，目的是为了保证缓存有足够的空闲空间。too much的比例由变量 innodb_max_dirty_pages_pct 控制，MySQL 5.6默认的值为75，即当脏页占缓冲池的百分之75后，就强制刷一部分脏页到磁盘。</li>
</ul>
<p>由于刷脏页需要一定的时间来完成，所以记录检查点的位置是在每次刷盘结束之后才在redo log中标记的。</p>
<blockquote>
<ul>
<li>MySQL停止时是否将脏数据和脏日志刷入磁盘，由变量innodb_fast_shutdown={ 0|1|2 }控制，默认值为1，即停止时只做一部分purge，忽略大多数flush操作(但至少会刷日志)，在下次启动的时候再flush剩余的内容，实现fast shutdown。</li>
</ul>
</blockquote>

        <h3 id="innodb的恢复行为">
          <a href="#innodb的恢复行为" class="heading-link"><i class="fas fa-link"></i></a><a href="#innodb的恢复行为" class="headerlink" title="innodb的恢复行为"></a>innodb的恢复行为</h3>
      <p>在启动innodb的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。</p>
<p>因为redo log记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志(如二进制日志)要快很多。而且，innodb自身也做了一定程度的优化，让恢复速度变得更快。</p>
<p>重启innodb时，checkpoint表示已经完整刷到磁盘上data page上的LSN，因此恢复时仅需要恢复从checkpoint开始的日志部分。例如，当数据库在上一次checkpoint的LSN为10000时宕机，且事务是已经提交过的状态。启动数据库时会检查磁盘中数据页的LSN，如果数据页的LSN小于日志中的LSN，则会从检查点开始恢复。</p>
<p>还有一种情况，在宕机前正处于checkpoint的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度。这时候一宕机，数据页中记录的LSN就会大于日志页中的LSN，在重启的恢复过程中会检查到这一情况，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。</p>
<p>另外，事务日志具有幂等性，所以多次操作得到同一结果的行为在日志中只记录一次。而二进制日志不具有幂等性，多次操作会全部记录下来，在恢复的时候会多次执行二进制日志中的记录，速度就慢得多。例如，某记录中id初始值为2，通过update将值设置为了3，后来又设置成了2，在事务日志中记录的将是无变化的页，根本无需恢复；而二进制会记录下两次update操作，恢复时也将执行这两次update操作，速度比事务日志恢复更慢。</p>

        <h3 id="binlog和事务日志的先后顺序及group-commit">
          <a href="#binlog和事务日志的先后顺序及group-commit" class="heading-link"><i class="fas fa-link"></i></a><a href="#binlog和事务日志的先后顺序及group-commit" class="headerlink" title="binlog和事务日志的先后顺序及group commit"></a>binlog和事务日志的先后顺序及group commit</h3>
      <p>如果事务不是只读事务，即涉及到了数据的修改，默认情况下会在commit的时候调用fsync()将日志刷到磁盘，保证事务的持久性。</p>
<p>但是一次刷一个事务的日志性能较低，特别是事务集中在某一时刻时事务量非常大的时候。innodb提供了group commit功能，可以将多个事务的事务日志通过一次fsync()刷到磁盘中。</p>
<p>因为事务在提交的时候不仅会记录事务日志，还会记录二进制日志，但是它们谁先记录呢？二进制日志是MySQL的上层日志，先于存储引擎的事务日志被写入。<br>在MySQL5.6以前，当事务提交(即发出commit指令)后，MySQL接收到该信号进入commit prepare阶段；进入prepare阶段后，立即写内存中的二进制日志，写完内存中的二进制日志后就相当于确定了commit操作；然后开始写内存中的事务日志；最后将二进制日志和事务日志刷盘，它们如何刷盘，分别由变量 sync_binlog 和 innodb_flush_log_at_trx_commit 控制。</p>
<p>但因为要保证二进制日志和事务日志的一致性，在提交后的prepare阶段会启用一个prepare_commit_mutex锁来保证它们的顺序性和一致性。但这样会导致开启二进制日志后group commmit失效，特别是在主从复制结构中，几乎都会开启二进制日志。</p>
<p>在MySQL5.6中进行了改进。提交事务时，在存储引擎层的上一层结构中会将事务按序放入一个队列，队列中的第一个事务称为leader，其他事务称为follower，leader控制着follower的行为。虽然顺序还是一样先刷二进制，再刷事务日志，但是机制完全改变了：删除了原来的prepare_commit_mutex行为，也能保证即使开启了二进制日志，group commit也是有效的。</p>
<p>MySQL5.6中分为3个步骤：flush阶段、sync阶段、commit阶段。</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E4%BA%8B%E5%8A%A1.png">
      </p>
<ul>
<li>flush阶段：向内存中写入每个事务的二进制日志。</li>
<li>sync阶段：将内存中的二进制日志刷盘。若队列中有多个事务，那么仅一次fsync操作就完成了二进制日志的刷盘操作。这在MySQL5.6中称为BLGC(binary log group commit)。</li>
<li>commit阶段：leader根据顺序调用存储引擎层事务的提交，由于innodb本就支持group commit，所以解决了因为锁 prepare_commit_mutex 而导致的group commit失效问题。<br>在flush阶段写入二进制日志到内存中，但是不是写完就进入sync阶段的，而是要等待一定的时间，多积累几个事务的binlog一起进入sync阶段，等待时间由变量 binlog_max_flush_queue_time 决定，默认值为0表示不等待直接进入sync，设置该变量为一个大于0的值的好处是group中的事务多了，性能会好一些，但是这样会导致事务的响应时间变慢，所以建议不要修改该变量的值，除非事务量非常多并且不断的在写入和更新。</li>
</ul>
<p>进入到sync阶段，会将binlog从内存中刷入到磁盘，刷入的数量和单独的二进制日志刷盘一样，由变量 sync_binlog 控制。</p>
<p>当有一组事务在进行commit阶段时，其他新事务可以进行flush阶段，它们本就不会相互阻塞，所以group commit会不断生效。当然，group commit的性能和队列中的事务数量有关，如果每次队列中只有1个事务，那么group commit和单独的commit没什么区别，当队列中事务越来越多时，即提交事务越多越快时，group commit的效果越明显。</p>

        <h3 id="参考资料">
          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3>
      <ul>
<li><a href="www.cnblogs.com/wy123/p/8365234.html">MySQL 中的重做日志，回滚日志 ，以及二进制日志的简单总结</a></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.csdn.net/haiross/article/details/17003543">前滚和回滚的区别</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html">详细分析MySQL事务日志(redo log和undo log)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://focusss.github.io">大湾区码仔驰名商标</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://focusss.github.io/2019/03/29/MySQL-%E4%B8%AD%E7%9A%84%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%8C%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97-%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/">https://focusss.github.io/2019/03/29/MySQL-%E4%B8%AD%E7%9A%84%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%8C%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97-%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://focusss.github.io/tags/MySQL/">MySQL</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2019/04/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">分布式事务解决方案</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2019/03/29/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"><span class="paginator-prev__text">分布式ID生成方案</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">
          简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E6%BB%9A%E5%92%8C%E5%9B%9E%E6%BB%9A"><span class="toc-number">2.</span> <span class="toc-text">
          前滚和回滚</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E6%BB%9A"><span class="toc-number">2.1.</span> <span class="toc-text">
          前滚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A"><span class="toc-number">2.2.</span> <span class="toc-text">
          回滚</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%88redo-log%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">
          重做日志（redo log）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">
          作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AE%B9"><span class="toc-number">3.2.</span> <span class="toc-text">
          内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BA%A7%E7%94%9F"><span class="toc-number">3.3.</span> <span class="toc-text">
          什么时候产生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8A%E6%94%BE"><span class="toc-number">3.4.</span> <span class="toc-text">
          什么时候释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%BA%94%E7%9A%84%E7%89%A9%E7%90%86%E6%96%87%E4%BB%B6"><span class="toc-number">3.5.</span> <span class="toc-text">
          对应的物理文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%86%99%E7%9B%98%E7%9A%84%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">
          redo log是什么时候写盘的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.7.</span> <span class="toc-text">
          参数设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%EF%BC%88undo-log%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">
          回滚日志（undo log）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-number">4.1.</span> <span class="toc-text">
          作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AE%B9-1"><span class="toc-number">4.2.</span> <span class="toc-text">
          内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BA%A7%E7%94%9F-1"><span class="toc-number">4.3.</span> <span class="toc-text">
          什么时候产生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8A%E6%94%BE-1"><span class="toc-number">4.4.</span> <span class="toc-text">
          什么时候释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%BA%94%E7%9A%84%E7%89%A9%E7%90%86%E6%96%87%E4%BB%B6-1"><span class="toc-number">4.5.</span> <span class="toc-text">
          对应的物理文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">4.6.</span> <span class="toc-text">
          其他</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delete-update%E6%93%8D%E4%BD%9C%E7%9A%84%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">4.7.</span> <span class="toc-text">
          delete&#x2F;update操作的内部机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%EF%BC%88binlog%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">
          二进制日志（binlog）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-2"><span class="toc-number">5.1.</span> <span class="toc-text">
          作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AE%B9-2"><span class="toc-number">5.2.</span> <span class="toc-text">
          内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BA%A7%E7%94%9F-2"><span class="toc-number">5.3.</span> <span class="toc-text">
          什么时候产生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8A%E6%94%BE-2"><span class="toc-number">5.4.</span> <span class="toc-text">
          什么时候释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-1"><span class="toc-number">5.5.</span> <span class="toc-text">
          其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%88%B7%E7%9B%98%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">6.</span> <span class="toc-text">
          日志刷盘的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%B7%E7%9B%98%E7%9A%84%E8%A7%84%E5%88%99%E5%8F%8Acheckpoint"><span class="toc-number">7.</span> <span class="toc-text">
          数据页刷盘的规则及checkpoint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innodb%E7%9A%84%E6%81%A2%E5%A4%8D%E8%A1%8C%E4%B8%BA"><span class="toc-number">8.</span> <span class="toc-text">
          innodb的恢复行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binlog%E5%92%8C%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E7%9A%84%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F%E5%8F%8Agroup-commit"><span class="toc-number">9.</span> <span class="toc-text">
          binlog和事务日志的先后顺序及group commit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">10.</span> <span class="toc-text">
          参考资料</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/headImg.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">平安大赚 财丁兴旺</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">79</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">23</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">33</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>大湾区码仔驰名商标</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>