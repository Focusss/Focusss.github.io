<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="索引（Index）是帮助MySQL高效获取数据的数据结构。索引是对表中一列或多列的值进行排序的一种存储结构。索引也是表的组成部分，建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引项结构。">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL索引原理">
<meta property="og:url" content="https://focusss.github.io/2019/03/27/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="大 湾 区 码 仔&#39;s Blog">
<meta property="og:description" content="索引（Index）是帮助MySQL高效获取数据的数据结构。索引是对表中一列或多列的值进行排序的一种存储结构。索引也是表的组成部分，建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引项结构。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://focusss.github.io/2019/03/27/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/%E7%AE%80%E5%8D%95%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="https://focusss.github.io/2019/03/27/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/hash.png">
<meta property="og:image" content="https://focusss.github.io/2019/03/27/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/MyISAM%E7%B4%A2%E5%BC%95.png">
<meta property="og:image" content="https://focusss.github.io/2019/03/27/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/innodb%E7%B4%A2%E5%BC%951.png">
<meta property="og:image" content="https://focusss.github.io/2019/03/27/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/innod%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95.png">
<meta property="og:image" content="https://focusss.github.io/2019/03/27/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/%E7%B4%A2%E5%BC%95%E7%B2%BE%E7%A1%AE%E6%9F%A5%E6%89%BE.png">
<meta property="og:image" content="https://focusss.github.io/2019/03/27/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E6%89%BE.png">
<meta property="og:image" content="https://focusss.github.io/2019/03/27/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/%E7%B4%A2%E5%BC%95%E5%85%A8%E8%A1%A8%E6%9F%A5%E6%89%BE.png">
<meta property="og:image" content="https://focusss.github.io/2019/03/27/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE.png">
<meta property="og:image" content="https://focusss.github.io/2019/03/27/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/innodb%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE2.png">
<meta property="article:published_time" content="2019-03-27T12:52:26.000Z">
<meta property="article:modified_time" content="2021-12-11T11:32:13.319Z">
<meta property="article:author" content="大湾区码仔驰名商标">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://focusss.github.io/2019/03/27/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/%E7%AE%80%E5%8D%95%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86.png"><title>MySQL索引原理 | 大 湾 区 码 仔's Blog</title><link ref="canonical" href="https://focusss.github.io/2019/03/27/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">大 湾 区 码 仔's Blog</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">MySQL索引原理</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-03-27</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-12-11</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h3 id="索引概念">
          <a href="#索引概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#索引概念" class="headerlink" title="索引概念"></a>索引概念</h3>
      <p>索引（Index）是帮助MySQL高效获取数据的数据结构。索引是对表中一列或多列的值进行排序的一种存储结构。<br>索引也是表的组成部分，建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引项结构。</p>
<p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构。这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构就是索引。</p>
<p>数据写入到mysql的时候，每行数据按照过来的先后顺序，顺序写入到磁盘。如果没有任何索引，我们查找某个值的时候，需要遍历整个磁盘进行查找，对于那些经常用于查找的列，我们可以为其创建索引，例如简单的二叉树。二叉树的节点的值是该列的值，同时有一个指针指向该值对应的磁盘的位置，通过二叉树很快定位到要查找的值，获取到磁盘上的对应的行的位置，从而很快取出这一行，比遍历整个磁盘要快得多。</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E7%AE%80%E5%8D%95%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86.png">
      </p>

        <h3 id="创建索引的优势：">
          <a href="#创建索引的优势：" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建索引的优势：" class="headerlink" title="创建索引的优势："></a>创建索引的优势：</h3>
      <ol>
<li>提高数据的检索速度，降低数据库IO成本：使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度。</li>
<li>降低数据排序的成本，降低CPU消耗：索引之所以查的快，是因为先将数据排好序，若该字段正好需要排序，则真好降低了排序的成本。</li>
</ol>

        <h3 id="创建索引的劣势：">
          <a href="#创建索引的劣势：" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建索引的劣势：" class="headerlink" title="创建索引的劣势："></a>创建索引的劣势：</h3>
      <ol>
<li>占用存储空间：索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上。</li>
<li>降低更新表的速度：表的数据发生了变化，对应的索引也需要一起变更，从而降低的更新速度。否则索引指向的物理数据可能不对，这也是索引失效的原因之一。</li>
<li>优质索引创建难：索引的创建并非一日之功，也并非一直不变。需要频繁根据用户的行为和具体的业务逻辑去创建最佳的索引。</li>
</ol>

        <h3 id="为什么MySQL索引要用Hash、B-Tree，而不用二叉树、红黑树、BTree">
          <a href="#为什么MySQL索引要用Hash、B-Tree，而不用二叉树、红黑树、BTree" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么MySQL索引要用Hash、B-Tree，而不用二叉树、红黑树、BTree" class="headerlink" title="为什么MySQL索引要用Hash、B+Tree，而不用二叉树、红黑树、BTree"></a>为什么MySQL索引要用Hash、B+Tree，而不用二叉树、红黑树、BTree</h3>
      <p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。<br>这样的话，索引查找过程中就要产生磁盘I/O消耗。索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。</p>

        <h4 id="不用二叉树、红黑树的原因">
          <a href="#不用二叉树、红黑树的原因" class="heading-link"><i class="fas fa-link"></i></a><a href="#不用二叉树、红黑树的原因" class="headerlink" title="不用二叉树、红黑树的原因"></a>不用二叉树、红黑树的原因</h4>
      <p>首先二叉树不是自平衡的，插入新节点时，二叉搜索树在最坏的情况下可能会变成一个链表（当所有节点按从小到大的顺序依次插入后），为O(n)。而红黑树恰恰优化了二叉树的缺点，使插入、删除节点时能自平衡。但红黑树还是有些问题：那就是数据量大的话，红黑树的深度会很深，也就是说深度不可控，而造成磁盘IO读写过于频繁，另外由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，IO读写次数就更多了，这样一来查找数据还是会很耗时。</p>
<p>红黑树多用在内部排序，即全部在内存中的，C++的STL中map和set的内部实现就是红黑树，Java集合框架里TreeMap也是使用红黑树实现，<br>B树多用在内存里放不下，大部分数据存储在外存上时。因为B树层数少，因此可以确保每次操作，读取磁盘的次数尽可能的少。</p>

        <h4 id="使用hash">
          <a href="#使用hash" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用hash" class="headerlink" title="使用hash"></a>使用hash</h4>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="hash.png">
      <br>相比较于红黑树，hash可以固定“深度”，且映射到磁盘存储引用，这样查找数据直接告诉磁盘数据在哪，查找数据也挺快的，但是 hash 还是有些不足：那就是不能范围查找。</p>
<p>memory引擎就是使用hash索引。</p>

        <h4 id="不用BTree的原因">
          <a href="#不用BTree的原因" class="heading-link"><i class="fas fa-link"></i></a><a href="#不用BTree的原因" class="headerlink" title="不用BTree的原因"></a>不用BTree的原因</h4>
      <p>根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>但B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小。</p>
<p>B+树相对B树的优点：</p>
<p>1、B+树的所有Data域在叶子节点，所有关键字查询的路径长度相同，也让B+-tree的查询效率更加稳定。另外叶子节点增加一个指向相邻叶子节点的指针，遍历叶子节点就能获取全部数据，提高区间访问性能。</p>
<p>2、非叶子节点不存储数据，一个页所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。<br>结论：B+Tree 既减少查询次数又提供了很好的范围查询</p>

        <h3 id="Mysql-索引实现">
          <a href="#Mysql-索引实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#Mysql-索引实现" class="headerlink" title="Mysql 索引实现"></a>Mysql 索引实现</h3>
      <p>聚集索引： 索引 和 数据文件为同一个文件。<br>非聚集索引： 索引 和 数据文件分开的索引。<br>MyISAM 、 InnoDB 都使用B+Tree索引结构。但是底层索引存储不同，MyISAM 采用非聚集索引，而InnoDB采用聚集索引。<br>每个索引一个B+树， 一个B+树节点 = 一个物理Page（16K）</p>

        <h4 id="MyISAM索引实现-非聚集">
          <a href="#MyISAM索引实现-非聚集" class="heading-link"><i class="fas fa-link"></i></a><a href="#MyISAM索引实现-非聚集" class="headerlink" title="MyISAM索引实现(非聚集)"></a>MyISAM索引实现(非聚集)</h4>
      <p>原理：采用非聚集索引，索引文件(.myi)和数据(.myd)文件分离，索引文件仅保存数据记录的指针地址。叶子节点data域存储指向数据记录的指针地址。</p>
<p>MyISAM索引按照B+Tree搜索，如果指定的Key存在，则取出其data域的值，然后以data域值-数据指针地址去读取相应数据记录。<br>辅助索引和主索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如下图在col1上建立主索引，在col2上建立辅助索引。</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="MyISAM%E7%B4%A2%E5%BC%95.png">
      <br>采用MyISAM引擎创建的表产生3个文件： frm-表定义文件、 myi-索引文件、 myd-数据文件</p>

        <h4 id="InnoDB索引实现-聚集">
          <a href="#InnoDB索引实现-聚集" class="heading-link"><i class="fas fa-link"></i></a><a href="#InnoDB索引实现-聚集" class="headerlink" title="InnoDB索引实现(聚集)"></a>InnoDB索引实现(聚集)</h4>
      <p>原理：采用聚集索引，数据和索引文件为一个idb文件，表数据文件本身就是主索引，相邻的索引临近存储。 </p>
<p>叶节点data域保存了完整的数据记录（除主键id外其他列data）。 </p>
<p>采用InnoDB引擎创建的表产生2个文件：frm -表定义、 ibd: innoDB数据&amp;索引文件</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="innodb%E7%B4%A2%E5%BC%951.png">
      <br>在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="innod%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95.png">
      </p>
<p>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>

        <h4 id="与MyISAM索引的不同">
          <a href="#与MyISAM索引的不同" class="heading-link"><i class="fas fa-link"></i></a><a href="#与MyISAM索引的不同" class="headerlink" title="与MyISAM索引的不同"></a>与MyISAM索引的不同</h4>
      <p>1、InnoDB的数据文件本身就是索引文件<br>2、InnoDB的辅助索引data域存储相应记录主键的值而不是地址</p>

        <h3 id="索引查询实例流程">
          <a href="#索引查询实例流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#索引查询实例流程" class="headerlink" title="索引查询实例流程"></a>索引查询实例流程</h3>
      <p>1、索引精确查找:</p>
<p> 确定定位条件, 找到根节点Page No, 根节点读到内存, 逐层向下查找, 读取叶子节点Page,通过 二分查找找到记录或未命中。<br> （select * from user_info where id = 23）<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E7%B4%A2%E5%BC%95%E7%B2%BE%E7%A1%AE%E6%9F%A5%E6%89%BE.png">
      </p>
<p>2.索引范围查找：</p>
<p>读取根节点至内存, 确定索引定位条件id=18, 找到满足条件第一个叶节点, 顺序扫描所有结果, 直到终止条件满足id &lt; 22。<br>（select * from user_info where id &gt;= 18 and id &lt; 22）<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E6%89%BE.png">
      </p>
<p>3、全表扫描：<br>直接读取叶节点头结点， 顺序扫描， 返回符合条件记录， 到最终节点结束<br>（select * from user_info where name = ‘abc’）</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E7%B4%A2%E5%BC%95%E5%85%A8%E8%A1%A8%E6%9F%A5%E6%89%BE.png">
      </p>
<p>4、二级索引查找：<br>通过二级索引查出对应主键，拿主键回表查主键索引得到数据， 二级索引可筛选掉大量无效记录，提高效率<br>Create table table_x(int id primary key, varchar(64) name,key sec_index(name)<br>Select * from table_x where name = “d”;<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE.png">
      </p>

        <h3 id="MySQL索引类型">
          <a href="#MySQL索引类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#MySQL索引类型" class="headerlink" title="MySQL索引类型"></a>MySQL索引类型</h3>
      <p>mysql的索引分为单列索引(全文索引，主键索引，唯一索引，普通索引)和组合索引。<br>单列索引:一个索引只包含一个列，一个表可以有多个单列索引。<br>组合索引:一个组合索引包含两个或两个以上的列。</p>

        <h4 id="普通索引">
          <a href="#普通索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4>
      <p>建表时：INDEX IndexName(<code>字段名</code>(length)) </p>
<p>建表后：CREATE INDEX IndexName ON <code>TableName</code>(<code>字段名</code>(length)) </p>
<p>或ALTER TABLE TableName ADD INDEX IndexName(<code>字段名</code>(length))</p>
<p>注意：如果字段数据是CHAR，VARCHAR类型，可以指定length，其值小于字段的实际长度，如果是BLOB和TEXT类型就必须指定length。<br>这个length的用处是什么?</p>
<p>有时候需要在长文本字段上建立索引，但这种索引会增加索引的存储空间以及降低索引的效率，这时就可以用到length，创建索引时用到length的索引，我们叫做前缀索引，前缀索引是选择字段数据的前n个字符作为索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<p>前缀索引是一种能使索引更小，更快的有效办法，但是MySql无法使用前缀索引做ORDER BY 和 GROUP BY以及使用前缀索引做覆盖扫描。</p>

        <h4 id="唯一索引">
          <a href="#唯一索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4>
      <p>要求字段所有的值是唯一的，这一点和主键索引一样，但是允许有空值。<br>建表时：UNIQUE INDEX IndexName(<code>字段名</code>(length)) </p>
<p>建表后：CREATE UNIQUE  INDEX IndexName ON <code>TableName</code>(<code>字段名</code>(length)) </p>
<p>或ALTER TABLE TableName ADD UNIQUE  INDEX IndexName(<code>字段名</code>(length)）</p>

        <h4 id="主键索引">
          <a href="#主键索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4>
      <p>一般在建表的时候自动创建，主键一般会设为 int 而且是 AUTO_INCREMENT自增类型的</p>

        <h4 id="全文索引">
          <a href="#全文索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4>
      <p>假设字段的数据类型是长文本，文本字段上(text等)建立了普通索引，我们需要查找关键字的话，那么其条件只能是where column like ‘%xxxx%’ ，但是，这样做就会让索引失效，这时就需要全文索引了。<br>建表时：FULLTEXT INDEX IndexName(<code>字段名</code>(length)) </p>
<p>建表后：CREATE FULLTEXT  INDEX IndexName ON <code>TableName</code>(<code>字段名</code>(length)) </p>
<p>或ALTER TABLE TableName ADD FULLTEXT  INDEX IndexName(<code>字段名</code>(length)）</p>
<p>使用：<br>SELECT * FROM TableName<br>WHERE MATCH(column1， column2) AGAINST(‘xxx′， ‘sss′， ‘ddd′)<br>这条命令将把column1和column2字段里有xxx、sss和ddd的数据记录全部查询出来。</p>

        <h4 id="组合索引">
          <a href="#组合索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h4>
      <p>假设字段a，b都有索引，我们的查询条件是a=1，b=2查询过程是mysql会先挑选出符合a=1的结果集，再在这些结果集中挑选b=2的结果集，但是mysql并不会在查询a，b时都用到索引，只会用其中一个，这和我们的预期不一样，所以，我们要使用组合索引</p>
<p>建表时：INDEX IndexName(<code>字段名</code>(length)，<code>字段名</code>(length)，……..) </p>
<p>建表后：CREATE INDEX IndexName ON <code>TableName</code>(<code>字段名</code>(length)，<code>字段名</code>(length)，……..) </p>
<p>或ALTER TABLE TableName ADD INDEX IndexName(<code>字段名</code>(length)，<code>字段名</code>(length)，……..) </p>
<p>在最左匹配原则中，有如下说明：</p>
<blockquote>
<ul>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整（按照索引列来检索匹配）。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
</ul>
</blockquote>

        <h3 id="索引失效（or、like-、类型转换、函数、表达式）">
          <a href="#索引失效（or、like-、类型转换、函数、表达式）" class="heading-link"><i class="fas fa-link"></i></a><a href="#索引失效（or、like-、类型转换、函数、表达式）" class="headerlink" title="索引失效（or、like%、类型转换、函数、表达式）"></a>索引失效（or、like%、类型转换、函数、表达式）</h3>
      <ol>
<li>如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</li>
</ol>
<ol start="2">
<li><p>mysql会按照联合索引从左往右进行匹配，直到遇到范围查询，如：&gt;,&lt;,between,like等就停止匹配，<br>a = 1 and b =2 and  c &gt; 3 and d = 4，如果建立（a,b,c,d）顺序的索引，d是不会使用索引的。<br>但如果联合索引是（a,b,d,c）的话，则a b d c都可以使用到索引，只是最终c是一个范围值。</p>
</li>
<li><p>like查询以%开头</p>
</li>
<li><p>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引，也是发生类型转换</p>
</li>
<li><p>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</p>
</li>
<li><p>索引列不能是表达式的一部分，也不能作为函数的参数，否则无法使用索引查询。下面是例子：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user_test WHERE user_name = concat(user_name, &#x27;fei&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li>
</ol>

        <h3 id="order-by使用索引">
          <a href="#order-by使用索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#order-by使用索引" class="headerlink" title="order by使用索引"></a>order by使用索引</h3>
      <p>order by排序有两种排序方式：using filesort使用算法在内存中排序以及使用mysql的索引进行排序；我们在部分情况下希望的是使用索引。</p>
<p>如果ID是单列索引，则order by会使用索引，如：</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> test_index <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span>;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>如果ID是单列索引，name不是索引或者name也是单列索引，则order by不会使用索引。</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="keyword">select</span> test_index <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> name <span class="keyword">desc</span>;</span><br></pre></td></tr></table></div></figure>
<p>因为Mysql的一次查询只会从众多索引中选择一个索引，而这次查询中使用的是ID列索引，而不是name列索引。在这种场景下，如果想让order by也使用索引的话，就建立联合索引（id，name），这里需要注意最左前缀原则，不要建立这样的联合索引（name，id）。</p>
<p>最后需要注意mysql对排序记录的大小有限制：max_length_for_sort_data 默认为1024；也就意味着如果需要排序的数据量大于1024，则order by不会使用索引，而是使用using filesort。</p>

        <h3 id="索引创建的几个原则">
          <a href="#索引创建的几个原则" class="heading-link"><i class="fas fa-link"></i></a><a href="#索引创建的几个原则" class="headerlink" title="索引创建的几个原则"></a>索引创建的几个原则</h3>
      <p>1、适合索引的列是出现在WHERE 子句中的列<br>2、使用惟一索引<br>  具有多个重复值的列，其索引效果最差，比如性别全是男的记录，对于MyISAM引擎来说，因为这时查找的时间就是T扫描整个索引表+T扫描整个表，那么耗时肯定过大了。对于InnoDB引擎来说，默认是有主键索引的，性别就相当于辅助索引了，这时每找到一个辅助索引节点就要去主键索引，也是相当于遍历辅助索引链表+整颗主键索引树。<br>3、使用短索引<br>    如果对串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做。例如，如果有一个CHAR(200) 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。对前10 个或20 个字符进行索引能够节省大量索引空间，也可能会使查询更快。较小的索引涉及的磁盘I/O 较少，较短的值比较起来更快。更为重要的是，对于较短的键值，索引高速缓存中的块能容纳更多的键值，因此，MySQL也可以在内存中容纳更多的值。这增加 了找到行而不用读取索引中较多块的可能性<br>4、不要过度索引<br>   每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能。在修改表的内容时，索引必须进行更新，有时可能需要重构，因此，索引越多，所花的时间越长。<br>5、考虑在列上进行的比较类型<br>    索引可用于“ &lt;”、“ &lt; = ”、“ = ”、“ &gt; =”、“ &gt; ”和BETWEEN 运算。<br>6、尽量选择区分度高的列作为索引，区分度的公式是 <code>COUNT(DISTINCT col) / COUNT(*)</code>，表示字段不重复的比率，比率越大我们扫描的记录数就越少。</p>

        <h3 id="什么时候不创建索引">
          <a href="#什么时候不创建索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么时候不创建索引" class="headerlink" title="什么时候不创建索引"></a>什么时候不创建索引</h3>
      <p>1、表记录太少<br>如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块，这种情况下至少要往返读取数据块两次。而不用索引的情况下ORACLE会将所有的数据一次读出，处理速度显然会比用索引快。</p>
<p>2、唯一性太差的字段<br>如状态字段、类型字段。那些只存储固定几个值的字段，例如用户登录状态、消息的status等。<br>这个涉及到了索引扫描的特性。例如：通过索引查找键值为A和B的某些数据，通过A找到某条相符合的数据，这条数据在X页上面，然后继续扫描，又发现符合A的数据出现在了Y页上面，那么存储引擎就会丢弃X页面的数据，然后存储Y页面上的数据，一直到查找完所有对应A的数据，然后查找B字段，发现X页面上面又有对应B字段的数据，那么他就会再次扫描X页面，等于X页面就会被扫描2次甚至多次。以此类推，所以同一个数据页可能会被多次重复的读取，丢弃，在读取，这无疑给存储引擎极大地增加了IO的负担。</p>
<p>select * from tb where gender=’男’这种不仅需要扫描这个索引  而且去取有‘男’的数据块基本覆盖了整个表所涉及的数据块</p>
<p>3、唯一性太差的字段</p>
<p>当你为这个字段创建索引时候，当你再次更新这个字段数据时，数据库会自动更新他的索引，所以当这个字段更新太频繁地时候那么就是不断的更新索引。<br>如果一个字段同一个时间段内被更新多次，那么不能为他建立索引。</p>

        <h3 id="思考">
          <a href="#思考" class="heading-link"><i class="fas fa-link"></i></a><a href="#思考" class="headerlink" title="思考"></a>思考</h3>
      
        <h4 id="InnoDB索引为什么不建议使用过长的字段作为主键">
          <a href="#InnoDB索引为什么不建议使用过长的字段作为主键" class="heading-link"><i class="fas fa-link"></i></a><a href="#InnoDB索引为什么不建议使用过长的字段作为主键" class="headerlink" title="InnoDB索引为什么不建议使用过长的字段作为主键"></a>InnoDB索引为什么不建议使用过长的字段作为主键</h4>
      <p>  因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大</p>

        <h4 id="为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？">
          <a href="#为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？" class="headerlink" title="为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？"></a>为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？</h4>
      <p>InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p>
<p>![](innodb自增主键 1.png)<br>如果表使用自增主键，那么每次插入新的记录，<strong>记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上</strong>。</p>
<p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="innodb%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE2.png">
      </p>
<p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>

        <h4 id="为什么非主键索引结构叶子节点存储的是主键值？">
          <a href="#为什么非主键索引结构叶子节点存储的是主键值？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么非主键索引结构叶子节点存储的是主键值？" class="headerlink" title="为什么非主键索引结构叶子节点存储的是主键值？"></a>为什么非主键索引结构叶子节点存储的是主键值？</h4>
      <p>1、节省空间<br>根据主键就可以找到主键索引中对应的叶子节点，不用再多存储一份相同的数据。</p>
<p>2、数据一致性<br>如果主键索引结构和非主键索引结构都含有相同的数据，那么在更新数据的时候，就要同时更新两个索引结构</p>

        <h4 id="什么时候用MyISAM，什么时候用Innodb">
          <a href="#什么时候用MyISAM，什么时候用Innodb" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么时候用MyISAM，什么时候用Innodb" class="headerlink" title="什么时候用MyISAM，什么时候用Innodb?"></a>什么时候用MyISAM，什么时候用Innodb?</h4>
      <p>主要区别：<br>1).MyISAM是非事务安全型的，而InnoDB是事务安全型的。<br>2).MyISAM锁的粒度是表级，而InnoDB支持行级锁定。<br>3).MyISAM支持全文类型索引，而InnoDB不支持全文索引。<br>4).MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。<br>5).MyISAM表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。<br>6).InnoDB表比MyISAM表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。</p>
<p>应用场景：<br>1).MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。<br>2).InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</p>
<p>INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。</p>

        <h4 id="主索引和辅助索引">
          <a href="#主索引和辅助索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#主索引和辅助索引" class="headerlink" title="主索引和辅助索引"></a>主索引和辅助索引</h4>
      <p>一个主文件仅有一个主索引，但可以有多个辅助索引</p>

        <h4 id="为什么MyISAM会比Innodb的查询速度快">
          <a href="#为什么MyISAM会比Innodb的查询速度快" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么MyISAM会比Innodb的查询速度快" class="headerlink" title="为什么MyISAM会比Innodb的查询速度快"></a>为什么MyISAM会比Innodb的查询速度快</h4>
      <p>INNODB在做SELECT的时候，要维护的东西比MYISAM引擎多很多:<br>1）数据块，INNODB要缓存，MYISAM只缓存索引块，  这中间还有换进换出的减少；
 </p>
<p>2）innodb寻址要映射到块，再到行，MYISAM记录的直接是文件的OFFSET，定位比INNODB要快</p>
<p>3）INNODB还需要维护MVCC一致；虽然你的场景没有，但他还是需要去检查和维护<br>MVCC (Multi-Version Concurrency Control)多版本并发控制 </p>
<p>注释：<br>InnoDB：通过为每一行记录添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。但是InnoDB并不存储这些事件发生时的实际时间，相反它只存储这些事件发生时的系统版本号。这是一个随着事务的创建而不断增长的数字。每个事务在事务开始时会记录它自己的系统版本号。每个查询必须去检查每行数据的版本号与事务的版本号是否相同。让我们来看看当隔离级别是REPEATABLEREAD时这种策略是如何应用到特定的操作的：<br>　　SELECT InnoDB必须每行数据来保证它符合两个条件：<br>　　1、InnoDB必须找到一个行的版本，它至少要和事务的版本一样老(也即它的版本号不大于事务的版本号)。这保证了不管是事务开始之前，或者事务创建时，或者修改了这行数据的时候，这行数据是存在的。<br>　　2、这行数据的删除版本必须是未定义的或者比事务版本要大。这可以保证在事务开始之前这行数据没有被删除</p>

        <h4 id="myisam-和-innodb中count-查询快慢原理">
          <a href="#myisam-和-innodb中count-查询快慢原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#myisam-和-innodb中count-查询快慢原理" class="headerlink" title="myisam 和 innodb中count(*)查询快慢原理"></a>myisam 和 innodb中count(*)查询快慢原理</h4>
      <p>在myisam中count(*)查询,myisam引擎很容易获得总行数的统计。查询速度变得更快。因为myisam存储引擎已经存储了表的总行数。每次新增加一行,这个计数器就加1。也就是说，把表的总数缓存在索引中了。</p>
<p>注意:</p>
<p>myisam存储引擎的表，count()速度快的也仅仅是不带where条件的count。这个想想容易理解的，因为你带了where限制条件，原来所以中缓存的表总数能够直接返回用吗？不能用。这个查询引擎也是需要根据where条件去表中扫描数据，进行统计返回的。</p>
<p>针对Innodb表,尽量不执行 SELECT COUNT() 语句,因为Innodb表没有类似MyISAM那样的内部计数器来记录表记录总量,执行这个操作将会全表扫描,速度很慢。所以呢，表的行数越多，扫描的时间就越多。当你表行数还是小数量的时候体会不出速度差距。比如百万也感觉不出明显。上千万就会很明显速度差别了。</p>

        <h4 id="哪些列比较适合做索引">
          <a href="#哪些列比较适合做索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#哪些列比较适合做索引" class="headerlink" title="哪些列比较适合做索引"></a>哪些列比较适合做索引</h4>
      <p>用于索引的最好的备选数据列是那些出现在WHERE子句、join子句、ORDER BY或GROUP BY子句中的列。仅仅出现在SELECT关键字后面的输出数据列列表中的数据列不是很好的备选列</p>
<p>在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。</p>

        <h3 id="参考资料">
          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3>
      <ul>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.jianshu.com/p/1775b4ff123a">干货：mysql索引的数据结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.csdn.net/caijunsen/article/details/83045985">深入理解Mysql索引底层数据结构与算法</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.jianshu.com/p/486a514b0ded">MYSQL-B+TREE索引原理</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36711757/article/details/80642931">MYSQL索引详解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.cnblogs.com/dongguacai/p/7238663.html">MySQL索引优化</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/38328?spm=a2c4e.11155435.0.0.5011772ejZLrnv">数据库索引的实现原理及查询优化</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://focusss.github.io">大湾区码仔驰名商标</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://focusss.github.io/2019/03/27/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/">https://focusss.github.io/2019/03/27/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://focusss.github.io/tags/MySQL/">MySQL</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2019/03/28/MySQL%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90%E6%93%8D%E4%BD%9C%E8%BF%87%E7%A8%8B/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">MySQL优化分析操作过程</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2019/03/27/B%E6%A0%91%E4%B8%8EB-%E6%A0%91/"><span class="paginator-prev__text">B树与B+树</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">
          索引概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">
          创建索引的优势：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8A%A3%E5%8A%BF%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">
          创建索引的劣势：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E7%B4%A2%E5%BC%95%E8%A6%81%E7%94%A8Hash%E3%80%81B-Tree%EF%BC%8C%E8%80%8C%E4%B8%8D%E7%94%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81BTree"><span class="toc-number">4.</span> <span class="toc-text">
          为什么MySQL索引要用Hash、B+Tree，而不用二叉树、红黑树、BTree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E7%94%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">4.1.</span> <span class="toc-text">
          不用二叉树、红黑树的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8hash"><span class="toc-number">4.2.</span> <span class="toc-text">
          使用hash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E7%94%A8BTree%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">4.3.</span> <span class="toc-text">
          不用BTree的原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql-%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">
          Mysql 索引实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0-%E9%9D%9E%E8%81%9A%E9%9B%86"><span class="toc-number">5.1.</span> <span class="toc-text">
          MyISAM索引实现(非聚集)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0-%E8%81%9A%E9%9B%86"><span class="toc-number">5.2.</span> <span class="toc-text">
          InnoDB索引实现(聚集)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8EMyISAM%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">5.3.</span> <span class="toc-text">
          与MyISAM索引的不同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E5%AE%9E%E4%BE%8B%E6%B5%81%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">
          索引查询实例流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.</span> <span class="toc-text">
          MySQL索引类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">7.1.</span> <span class="toc-text">
          普通索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-number">7.2.</span> <span class="toc-text">
          唯一索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">7.3.</span> <span class="toc-text">
          主键索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-number">7.4.</span> <span class="toc-text">
          全文索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">7.5.</span> <span class="toc-text">
          组合索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%88or%E3%80%81like-%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">
          索引失效（or、like%、类型转换、函数、表达式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#order-by%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">9.</span> <span class="toc-text">
          order by使用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8E%9F%E5%88%99"><span class="toc-number">10.</span> <span class="toc-text">
          索引创建的几个原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">11.</span> <span class="toc-text">
          什么时候不创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">12.</span> <span class="toc-text">
          思考</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E8%BF%87%E9%95%BF%E7%9A%84%E5%AD%97%E6%AE%B5%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE"><span class="toc-number">12.1.</span> <span class="toc-text">
          InnoDB索引为什么不建议使用过长的字段作为主键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88InnoDB%E8%A1%A8%E5%BF%85%E9%A1%BB%E6%9C%89%E4%B8%BB%E9%94%AE%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E6%95%B4%E5%9E%8B%E7%9A%84%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="toc-number">12.2.</span> <span class="toc-text">
          为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%AF%E4%B8%BB%E9%94%AE%E5%80%BC%EF%BC%9F"><span class="toc-number">12.3.</span> <span class="toc-text">
          为什么非主键索引结构叶子节点存储的是主键值？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8MyISAM%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8Innodb"><span class="toc-number">12.4.</span> <span class="toc-text">
          什么时候用MyISAM，什么时候用Innodb?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%B4%A2%E5%BC%95%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="toc-number">12.5.</span> <span class="toc-text">
          主索引和辅助索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88MyISAM%E4%BC%9A%E6%AF%94Innodb%E7%9A%84%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E5%BF%AB"><span class="toc-number">12.6.</span> <span class="toc-text">
          为什么MyISAM会比Innodb的查询速度快</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#myisam-%E5%92%8C-innodb%E4%B8%ADcount-%E6%9F%A5%E8%AF%A2%E5%BF%AB%E6%85%A2%E5%8E%9F%E7%90%86"><span class="toc-number">12.7.</span> <span class="toc-text">
          myisam 和 innodb中count(*)查询快慢原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%88%97%E6%AF%94%E8%BE%83%E9%80%82%E5%90%88%E5%81%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">12.8.</span> <span class="toc-text">
          哪些列比较适合做索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">13.</span> <span class="toc-text">
          参考资料</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/headImg.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">平安大赚 财丁兴旺</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">84</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">23</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">33</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>大湾区码仔驰名商标</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>