<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP层是位于IP层之上，应用层之下的中间层。">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP协议详解">
<meta property="og:url" content="https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="大 湾 区 码 仔&#39;s Blog">
<meta property="og:description" content="TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP层是位于IP层之上，应用层之下的中间层。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/ACK1.png">
<meta property="og:image" content="https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/ACK2.png">
<meta property="og:image" content="https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/%E5%BA%8F%E5%88%97%E5%8F%B7.png">
<meta property="og:image" content="https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.png">
<meta property="og:image" content="https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/SACK.png">
<meta property="og:image" content="https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png">
<meta property="og:image" content="https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png">
<meta property="og:image" content="https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE.png">
<meta property="og:image" content="https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%94%B9%E8%BF%9B.png">
<meta property="og:image" content="https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0.png">
<meta property="og:image" content="https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/%E7%AA%97%E5%8F%A3%E6%BB%91%E5%8A%A8%E4%B8%A2ACK.png">
<meta property="og:image" content="https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/%E7%AA%97%E5%8F%A3%E6%8E%A2%E6%B5%8B.png">
<meta property="article:published_time" content="2019-04-11T12:51:07.000Z">
<meta property="article:modified_time" content="2021-12-11T09:37:31.079Z">
<meta property="article:author" content="大湾区码仔驰名商标">
<meta property="article:tag" content="网络协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/ACK1.png"><title>TCP协议详解 | 大 湾 区 码 仔's Blog</title><link ref="canonical" href="https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: {"avoidBanner":false},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">大 湾 区 码 仔's Blog</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">TCP协议详解</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-04-11</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-12-11</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h3 id="简介">
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h3>
      <p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。</p>
<p>TCP的特征：序列化+确认应答、超时重发、流量控制、拥塞控制等等。</p>
<p>TCP/IP 中有两个具有代表性的传输层协议，分别是TCP、UDP。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p>

        <h3 id="特点">
          <a href="#特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#特点" class="headerlink" title="特点"></a>特点</h3>
      <p>TCP位于传输层，提供可靠的字节流服务（Byte Stream Service）。</p>
<ol>
<li>字节流服务：为了方便传输，将大块数据分割以报文段（segment）为单位的数据包进行管理。应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。 </li>
</ol>
<ul>
<li>当数据块太长时，TCP中的缓存可以将应用程序发来的数据块划分成若干个短部分再传送。</li>
<li>当数据块太短时，例如应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</li>
</ul>
<ol start="2">
<li>可靠的传输服务：能够把数据准确可靠地传给对方。</li>
</ol>

        <h3 id="优缺点">
          <a href="#优缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3>
      <ol>
<li>优点：</li>
</ol>
<ul>
<li>可靠、稳定性 </li>
<li>传递数据前，会有三次握手建立连接 ；</li>
<li>传递数据时，有确认、窗口、重传、拥塞控制；</li>
<li>传递数据后，会断开连接节省系统资源；</li>
</ul>
<ol start="2">
<li>缺点：</li>
</ol>
<ul>
<li><p>传输慢，效率低，占用系统资源高： </p>
<pre><code>        传递数据前，建立连接需要耗时
        传递数据时，确认、重传、拥塞等会消耗大量时间以及CPU和内存等硬件资源
</code></pre>
</li>
<li><p>易被攻击 ：因为有确认机制，三次握手等机制，容易被人利用，实现DOS 、DDOS攻击</p>
</li>
</ul>
<p>TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。为了通过IP数据报实现可靠传输，需要考虑很多事情，例如数据破坏、丢包、重复以及分片顺序混乱等问题。</p>
<p>TCP通过检验和、序列号、确认应答、重发控制、连接管理及窗口等机制实现可靠传输。</p>

        <h3 id="可靠传输（序列号-确认应答）">
          <a href="#可靠传输（序列号-确认应答）" class="heading-link"><i class="fas fa-link"></i></a><a href="#可靠传输（序列号-确认应答）" class="headerlink" title="可靠传输（序列号+确认应答）"></a>可靠传输（序列号+确认应答）</h3>
      
        <h4 id="确认应答ACK（Positive-Acknowledgment）">
          <a href="#确认应答ACK（Positive-Acknowledgment）" class="heading-link"><i class="fas fa-link"></i></a><a href="#确认应答ACK（Positive-Acknowledgment）" class="headerlink" title="确认应答ACK（Positive Acknowledgment）"></a>确认应答ACK（Positive Acknowledgment）</h4>
      <p>在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。此消息叫做确认应答ACK。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="ACK1.png">
      <br>TCP通过肯定的确认回答（ACK）实现可靠的数据传输。当发送端将数据发出后等待对方的确认应答，若有应答则表示对方已成功接收。反之则数据丢失可能性大。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="ACK2.png">
      <br>在一定时间内没有等待确认应答，发送端就可以认为数据已丢失，进行重发。因此即使丢包，仍然可以保证数据传输到对方。（注意：未收到应答不一定是数据丢失，可能是确认应答在途中丢失）</p>

        <h4 id="序列号">
          <a href="#序列号" class="heading-link"><i class="fas fa-link"></i></a><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h4>
      <p>此外，也有可能是其它原因导致发送端未收到确认应答，主机只需按照机制重发数据即可，但对于目标主机而言，它会收到相同的数据包，为此引入一种机制，能够识别是否已经接受数据和判断是否需要接收。</p>
<p>上述这些确认应答处理、重发控制以及重复控制等功能都可以通过序列号实现。序列号是按顺序给发送数据的每一个字节（8位字节）都标上编号。<strong>接收端查询接收数据TCP首部中的序列号和数据长度，将下一步应接收的序号作为确认应答返送回去</strong>。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E5%BA%8F%E5%88%97%E5%8F%B7.png">
      </p>
<p>综上，通过序列号和确认应答，TCP可以实现可靠传输。</p>

        <h3 id="重发超时">
          <a href="#重发超时" class="heading-link"><i class="fas fa-link"></i></a><a href="#重发超时" class="headerlink" title="重发超时"></a>重发超时</h3>
      <p>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔，如果超过这个时间仍未收到确认应答，发送端将进行数据重发。TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<blockquote>
<ul>
<li>接收端给发送端的Ack确认只会确认最后一个连续的包</li>
</ul>
</blockquote>
<p>发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？</p>
<ol>
<li>超时重传机制</li>
</ol>
<p>发送端继续等待3，即使收到了4，也不会回复ack。当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 4，意味着3和4都收到了。此机制下有两种应对方法：</p>
<ul>
<li>仅重传timeout的包。也就是第3份数据。</li>
<li>重传timeout后所有的数据，也就是第3，4，5这三份数据<br>第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽。但其实这两种方法都不太好，都需要等待timeout（timeout可能会很长）。</li>
</ul>
<ol start="2">
<li>快速重传（Fast Retransmit ）机制</li>
</ol>
<p>TCP引入了一种叫Fast Retransmit 的算法，不以时间驱动，而以数据驱动重传。如果数据包没有连续到达，就ack最后那个可能被丢了的包，如果发送端连续收到3次相同的ack就重传。其好处是发送端不需要一直等待，直到timeout后再重传。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.png">
      </p>
<p>如上图，再举个例子，如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。</p>
<p>虽然快速重传机制解决了timeout的问题，还遗留了之前提出的一个问题：是重传之前的一个还是重传所有数据包？对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的。</p>
<p>因此，快速重传机制仍然是有缺点的！</p>
<ol start="3">
<li>SACK 方法<br>Selective Acknowledgment (SACK)方法：需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参考下图：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="SACK.png">
      <br>此方法是基于Fast Retransmit的算法上的优化，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。</li>
</ol>
<p>但是！SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。</p>
<ol start="4">
<li>Duplicate SACK – 重复收到数据的问题<br>主要使用了SACK来告诉发送方有哪些数据被重复接收了，D-SACK使用了SACK的第一个段来做标志：</li>
</ol>
<ul>
<li>如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK</li>
<li>如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK</li>
</ul>
<p>D-SACK方法的好处：</p>
<ul>
<li>可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。</li>
<li>是不是自己的timeout太小了，导致重传。</li>
<li>网络上出现了先发的包后到的情况（又称reordering）</li>
<li>网络上是不是把我的数据包给复制了</li>
</ul>

        <h3 id="连接管理">
          <a href="#连接管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3>
      <p>为了准确无误地将数据送达目标处，TCP协议采用了三次握手（three-way handshaking）策略。用TCP协议将数据包送出去后，TCP一定会向对方确认是否成功送达。若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的顺序包。</p>
<ol>
<li>三次握手过程</li>
</ol>
<p>定义：三次握手，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。</p>
<p>目的：是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息</p>
<p>在socket编程中，客户端执行connect()时，将触发三次握手。</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png">
      </p>
<ul>
<li><p>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</p>
</li>
<li><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
</li>
<li><p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>完成三次握手，客户端与服务器开始传送数据。</p>
</li>
</ul>
<ol start="2">
<li>四次挥手<br>所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png">
      <br>由于TCP连接时全双工的，因此每个方向都必须要单独进行关闭。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</li>
</ol>
<p>当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。</p>
<ul>
<li><p>第一次挥手：主动关闭方发送一个FIN并进入FIN_WAIT1状态</p>
</li>
<li><p>第二次挥手：被动关闭方接收到主动关闭方发送的FIN并发送ACK，此时被动关闭方进入CLOSE_WAIT状态；主动关闭方收到被动关闭方的ACK后，进入FIN_WAIT2状态</p>
</li>
<li><p>第三次挥手：被动关闭方发送一个FIN并进入LAST_ACK状态</p>
</li>
<li><p>第四次挥手：主动关闭方收到被动关闭方发送的FIN并发送ACK，此时主动关闭方进入TIME_WAIT状态，经过2MSL时间后关闭连接；被动关闭方收到主动关闭方的ACK后，关闭连接</p>
</li>
</ul>
<blockquote>
<ul>
<li>MSL是Maximum Segment Lifetime，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</li>
</ul>
</blockquote>

        <h4 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢">
          <a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢</h4>
      <ul>
<li><p>对于3次握手：主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。</p>
</li>
<li><p>对于4次挥手：其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。</p>
</li>
</ul>
<p>服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。</p>
<p>而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>

        <h3 id="流控制（Flow-Control）">
          <a href="#流控制（Flow-Control）" class="heading-link"><i class="fas fa-link"></i></a><a href="#流控制（Flow-Control）" class="headerlink" title="流控制（Flow Control）"></a>流控制（Flow Control）</h3>
      
        <h4 id="滑动窗口协议">
          <a href="#滑动窗口协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4>
      <ol>
<li>特征定义</li>
</ol>
<ul>
<li>TCP协议中使用</li>
<li>维持发送方/接收方缓存区<br>此缓存区主要用于解决网络传输的不可靠问题</li>
</ul>
<ol start="2">
<li>提出问题</li>
</ol>
<p>如果没有滑动窗口协议，如何保证接收方能够收到正确有序的包？<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE.png">
      <br>如上图所示，发送方发送包1，接收方确认包1，发送包2，确认包2，这样即可解决不可靠性问题。但同时此过程的问题十分明显：吞吐量低，必须要等接收方确认完后才能发送下一个包。试考虑，若能连发几个包，接收方可以同时确认，这样效率岂不更高？</p>
<ol start="3">
<li>简单改进</li>
</ol>
<p>在此问题上，出现了以下改进：发送方可以同时发多个包，接收方一起确认。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%94%B9%E8%BF%9B.png">
      </p>
<ol start="4">
<li>滑动窗口实现<br>由此又衍生出一个问题，同时发包的数量多少才会是最优方案呢？例如发送方同时发送包1、2，在获得接收方确认包1消息后，能否不等包2确认信息，直接发送包3呢？</li>
</ol>
<p>这样很自然地思考到了“滑动窗口实现”。以下有16个数据包，发送方希望按照顺序发送，在接收方收到每个包后都逐一给予确认：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0.png">
      </p>
<ul>
<li><p>初始：（窗口为4到7） </p>
<blockquote>
<ul>
<li>1、2、3包已发送并且获取发送方Ack确认；</li>
<li>4、5、6、7包已发送但尚未获取发送方Ack确认；</li>
<li>8、9、10包待发送；</li>
<li>而11、12、13、14、15、16包未发送甚至都没有装入内存；</li>
</ul>
</blockquote>
</li>
<li><p>正常：（窗口为5到9） </p>
<blockquote>
<ul>
<li>1、2、3、4包已发送并且获取发送方Ack确认；</li>
<li>5、6、7、8、9包已发送但尚未获取发送方Ack确认；</li>
<li>10、11包待发送；</li>
<li>而12、13、14、15、16包未发送甚至都没有装入内存；<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E7%AA%97%E5%8F%A3%E6%BB%91%E5%8A%A8%E4%B8%A2ACK.png">
      </li>
</ul>
</blockquote>
</li>
<li><p>丢Ack：（窗口为5到11） </p>
<blockquote>
<ul>
<li>5、6、7、8、9包未收到Ack（丢Ack），在等待过程又发送了10、11包，此时窗口已满，无法读进包12，只能等待Ack。如果真的是丢包，始终无法收到Ack，此时超时重传机制会从包5开始重新发送。（注意，这里的Ack是按照顺序发送的！）</li>
</ul>
</blockquote>
</li>
<li><p>重发： （窗口为9到15） </p>
<blockquote>
<ul>
<li>5、6、7、8包获取发送方Ack确认；</li>
<li>9、10、11、12、13包已发送但尚未获取发送方Ack确认；</li>
<li>13、14包待发送；</li>
<li>而16包未发送甚至都没有装入内存；</li>
</ul>
</blockquote>
</li>
</ul>
<p>为了增加线路的吞吐量，改进原版方案，令发送方同时发送包；为了衡量同时发送的数量达到吞吐量最优解，从而引进滑动窗口机制；为了解决丢包等不可靠性问题导致发送方无法收到接收方的Ack，又引进了重发机制。</p>

        <h4 id="解释流控制">
          <a href="#解释流控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#解释流控制" class="headerlink" title="解释流控制"></a>解释流控制</h4>
      <ol>
<li>出现的问题</li>
</ol>
<p>发送端根据自己的实际情况发送数据，但是接收端在处理别的事（可能正处于高负荷的状态无法接收任何数据），而且此数据包并无重要意义，这样导致此包丢失又会触发重发机制，令网络流量无端浪费。</p>
<ol start="2">
<li>解决方法</li>
</ol>
<p>为了防止此现象发生，TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。这就是“控制流”。</p>
<ol start="3">
<li>具体操作</li>
</ol>
<p>接收端想发送端通知自己可以接收数据的大小，发送端发送时不会超过这个限度的数据，该大小限制被称为窗口大小。</p>
<p>TCP首部中专门有一个字段用来通知窗口大小。接收端将自己可接收的缓冲区大小放入字段中并通知发送端。此值越大代表网络的吞吐量越高。</p>
<p>当缓存区一旦面临数据溢出时，窗口大小的值也会随之被设置成一个更小的值发送给发送端，从而控制数据发送量。也就是说，发送端会根据接收端的指示，对发送数据量进行控制。这就形成了一个完整的TCP流控制。</p>
<p>查看下图示例：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="%E7%AA%97%E5%8F%A3%E6%8E%A2%E6%B5%8B.png">
      <br>如上图所示，当接收端收到从3001号开始的数据段后，缓冲区已满，需要暂时停止接收数据。之后在收到发送窗口更新通知后通信才得以继续进行。如果此窗口更新通知在传送途中丢失，可能导致无法继续通信。为避免此类问题产生，发送端主机会时不时发送一个叫做“窗口探测”的数据段，此数据段仅含一个字节以获取最新的窗口大小信息。</p>

        <h4 id="Zero-Window">
          <a href="#Zero-Window" class="heading-link"><i class="fas fa-link"></i></a><a href="#Zero-Window" class="headerlink" title="Zero Window"></a>Zero Window</h4>
      <p>发送端可以发送数据动态修改“滑动窗口”的大小，注意其值是可以为0的！那这样是否意味着发送端就不发数据了？确实如此，接收端都已经表示自己无力接收了，因此不会再发，类似于“Window Closed”。</p>
<p>解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP。即发送端在窗口变成0后，会发ZWP的包给接收端，让接收端来ack他的Window尺寸，一般这个值会设置成3次，第次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。</p>
<p>注意：只要有等待的地方都可能出现DDoS攻击，Zero Window也不例外，一些攻击者会在和HTTP建好链发完GET请求后，就把Window设置为0，然后服务端就只能等待进行ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。</p>

        <h3 id="拥塞控制（Congestion-Control）">
          <a href="#拥塞控制（Congestion-Control）" class="heading-link"><i class="fas fa-link"></i></a><a href="#拥塞控制（Congestion-Control）" class="headerlink" title="拥塞控制（Congestion Control）"></a>拥塞控制（Congestion Control）</h3>
      <p>有了TCP的窗口控制，收发端之间不再以一个数据段为单位发送确认应答，也能够连续发送大量数据包。但是刚开始通信就发送大量数据会引发其它问题。计算机网络处于一个共享的环境，因此有可能因为其他主机之间的通信使得网络拥堵，此时突然发送一个大量数据，可能导致整个网络瘫痪。</p>
<p>拥塞控制主要是四个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>

        <h4 id="慢启动（Slow-Start）">
          <a href="#慢启动（Slow-Start）" class="heading-link"><i class="fas fa-link"></i></a><a href="#慢启动（Slow-Start）" class="headerlink" title="慢启动（Slow Start）"></a>慢启动（Slow Start）</h4>
      <p>首先，为了在发送端调节待发送的数据量，定义了“拥塞窗口”的概念，在慢启动时将其设为1个数据段（IMSS）发送数据，之后每收到一次确认应答（ACK），拥塞窗口的值就加1。在发送数据段时，将拥塞窗口的大小与接收端通知的窗口大小做比较，以较小值为标准，发送比其还要小的数据量。</p>
<p>根据以上机制，可有效减少通信开始时连续发包导致的网络拥堵，还可以避免网络拥塞的情况。<br>慢启动的算法如下：(cwnd全称Congestion Window)</p>
<ul>
<li>连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。</li>
<li>每当收到一个ACK，cwnd++; 呈线性上升</li>
<li>每当过了一个RTT，cwnd = cwnd<code>*</code>2; 呈指数让升</li>
<li>还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”</li>
</ul>
<p>所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。</p>

        <h4 id="拥塞避免算法（Congestion-Avoidance）">
          <a href="#拥塞避免算法（Congestion-Avoidance）" class="heading-link"><i class="fas fa-link"></i></a><a href="#拥塞避免算法（Congestion-Avoidance）" class="headerlink" title="拥塞避免算法（Congestion Avoidance）"></a>拥塞避免算法（Congestion Avoidance）</h4>
      <p>前面慢启动的算法第四步中的ssthresh（slow start threshold）是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：</p>
<ul>
<li>收到一个ACK时，cwnd = cwnd + 1/cwnd</li>
<li>当每过一个RTT时，cwnd = cwnd + 1</li>
</ul>
<p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p>

        <h4 id="拥塞状态时的算法">
          <a href="#拥塞状态时的算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#拥塞状态时的算法" class="headerlink" title="拥塞状态时的算法"></a>拥塞状态时的算法</h4>
      <p>在讲解超时重传机制中提到TCP面临丢包时，有以下两个问题：</p>
<p>a)等到RTO 超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈：</p>
<blockquote>
<p>sshthresh =  cwnd /2<br>cwnd 重置为 1<br>进入慢启动过程</p>
</blockquote>
<p>b) Fast Retransmit算法，也就是在收到3个duplicate ACK时就开启重传，而不用等到RTO超时，TCP Tahoe的实现和RTO超时一样。TCP Reno的实现是：</p>
<blockquote>
<p>cwnd = cwnd /2<br>sshthresh = cwnd<br>进入快速恢复算法——Fast Recovery</p>
</blockquote>
<p>上面我们可以看到RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd&lt;=sshthresh时出现的丢包，那么TCP的sshthresh就会减了一半，然后等cwnd又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。</p>

        <h4 id="快速恢复算法（Fast-Recovery）">
          <a href="#快速恢复算法（Fast-Recovery）" class="heading-link"><i class="fas fa-link"></i></a><a href="#快速恢复算法（Fast-Recovery）" class="headerlink" title="快速恢复算法（Fast Recovery）"></a>快速恢复算法（Fast Recovery）</h4>
      <p>快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈。 注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新：</p>
<blockquote>
<p>cwnd = cwnd /2<br>sshthresh = cwnd</p>
</blockquote>
<p>真正的Fast Recovery算法如下：</p>
<ul>
<li>cwnd = sshthresh + 3 * MSS （3的意思是确认有3个数据包被收到了）</li>
<li>重传Duplicated ACKs指定的数据包</li>
<li>如果再收到 duplicated Acks，那么cwnd = cwnd +1</li>
<li>如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。</li>
</ul>
<p>仔细思考一下你会发现上面这个算法也有问题：它依赖于3个重复的Acks。</p>
<p>注意：3个重复的Acks并不代表只丢了一个数据包，很有可能不止一个。但此算法只会重传一个，而剩下的那些包只能等到RTO超时，从而导致一种可怕的现象：超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发Fast Recovery算法了。</p>

        <h3 id="TCP和UDP的区别">
          <a href="#TCP和UDP的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3>
      
        <h4 id="UDP（User-Datagram-Protocol）">
          <a href="#UDP（User-Datagram-Protocol）" class="heading-link"><i class="fas fa-link"></i></a><a href="#UDP（User-Datagram-Protocol）" class="headerlink" title="UDP（User Datagram Protocol）"></a>UDP（User Datagram Protocol）</h4>
      <p>用户数据包协议，UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为，同样出现丢包情况，UDP也不负责重发，也没有当包的到达顺序混乱纠正功能。如果需要这些细节控制，只能交由UDP的应用程序去处理。（UDP有点类似于用户说啥就听啥的机制）。</p>
<p>面向报文传输，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。</p>
<ul>
<li>若报文太长，则IP层需要分片，降低效率。</li>
<li>若报文太短，浪费资源。<br>UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。即应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。</li>
</ul>
<p>因此它有以下特点：</p>
<ul>
<li>传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快的把它扔到网络上</li>
<li>由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息</li>
<li>在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制</li>
<li>在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段</li>
<li>UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小</li>
<li>吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制</li>
<li>UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。</li>
</ul>
<p>优点</p>
<ul>
<li><p>传输速率快：传输数据前，不需要像TCP一样建立连接；传输数据时，没有确认、窗口、重传、拥塞控制等机制。</p>
</li>
<li><p>较安全：由于没有了TCP的一些机制，被攻击者利用的漏洞就少了<br>缺点</p>
</li>
<li><p>不可靠，不稳定：由于没有了TCP的机制，在数据传输时如果网络不好，很可能丢包</p>
</li>
</ul>

        <h4 id="区别">
          <a href="#区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#区别" class="headerlink" title="区别"></a>区别</h4>
      <p>TCP                      UDP</p>
<p>面向字节流              面向报文</p>
<p>一对一                  可以一对一，一对多</p>
<p>面向有链接的通信服务      面向无连接的通信服务</p>
<p>速度快                  速度慢</p>
<p>提供可靠的通信传输      不可靠,会丢包</p>
<p>保证数据包顺序          不保证</p>
<p>有流量控制，拥塞控制      没有</p>
<p>数据无边界              数据有边界</p>
<p>报头至少20字节          报头8字节</p>

        <h3 id="常见问题">
          <a href="#常见问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3>
      <ol>
<li>为什么UDP比TCP快</li>
</ol>
<p>因为TCP中连接需要三次握手，断开连接需要四次握手，传输过程中还有拥塞控制，控制流量等机制。</p>
<ol start="2">
<li>为什么TCP比UDP可靠</li>
</ol>
<p>TCP是面向有连接的，建立连接之后才发送数据；而UDP则不管对方存不存在都会发送数据。<br>TCP有确认机制，接收端每收到一个正确包都会回应给发送端。超时或者数据包不完整的话发送端会重传。UDP没有。因此可能丢包。</p>
<ol start="3">
<li>什么时候使用TCP</li>
</ol>
<p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p>
<p>例如日常生活中使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输</p>
<ol start="4">
<li>什么时候应该使用UDP</li>
</ol>
<p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。</p>
<p>比如日常生活中使用UDP协议的应用如下： QQ语音 QQ视频 TFTP</p>
<ol start="5">
<li>TCP无边界，UDP有边界</li>
</ol>
<p>TCP无边界：客户端分多次发送数据给服务器，若服务器的缓冲区够大，那么服务器端会在客户端发送完之后一次性接收过来，所以是无边界的。</p>
<p>UDP有边界：客户端每发送一次，服务器端就会接收一次，也就是说发送多少次就会接收多少次，因此是有边界的。</p>
<ol start="6">
<li>如果tcp建立连接时第三次握手失败，tcp会做何操作？<br>当客户端收到服务端的SYN+ACK应答后，其状态变为ESTABLISHED，并会发送ACK包给服务端，准备发送数据了。如果此时ACK在网络中丢失，过了超时计时器后，那么Server端会重新发送SYN+ACK包，重传次数根据/proc/sys/net/ipv4/tcp_synack_retries来指定，默认是5次。如果重传指定次数到了后，仍然未收到ACK应答，那么一段时间后，Server自动关闭这个连接。但是Client认为这个连接已经建立，如果Client端向Server写数据，Server端将以RST包响应，方能感知到Server的错误。</li>
</ol>
<p>当失败时服务器并不会重传ack报文，而是直接发送RTS报文段，进入CLOSED状态。这样做的目的是为了防止SYN洪泛攻击，即坏人伪造许多IP向server发送连接请求，从而将server的未连接队列塞满，浪费server的资源。</p>
<ol start="7">
<li><p>为什么需要第三次握手？<br>如果在client与server建立连接的过程中，由于网络不顺畅等原因造成的通信链路中存在着残留数据包。<br>如果只有两次握手，那么server收到了client的SYN=1的请求连接数据包之后，便会分配资源并且向client发送一个确认位ACK回复数据包。<br>当client与server建立连接，数据发送完毕并且关闭TCP连接之后，如果链路中的残留数据包才到达server，那么server就会认为client重新发送了一次连接申请，便会回复ACK包并且分配资源。并且一直等待client发送数据，这就会造成server的资源浪费。</p>
</li>
<li><p>三次握手有什么缺陷可以被黑客利用，用来对服务器进行攻击？<br>黑客仿造IP大量的向server发送TCP连接请求报文包，从而将server的半连接队列（上文所说的未连接队列，即server收到连接请求SYN之后将client加入半连接队列中）占满，从而使得server拒绝其他正常的连接请求。即拒绝服务攻击</p>
</li>
<li><p>怎么防范这种攻击？<br>1、缩短服务器接收客户端SYN报文之后的等待连接时间，即SYN timeout时间，也就是server接收到SYN报文段，到最后放弃此连接请求的超时时间，将SYN timeout设置的更低，便可以成倍的减少server的负荷，但是过低的SYN timeout可能会影响正常的TCP连接的建立，一旦网络不通畅便可能导致client连接请求失败</p>
</li>
</ol>
<p>2、SYN cookie + SYN proxy 无缝集成（较好的解决方案）</p>
<ul>
<li><p>SYN cookie：当server接收到client的SYN之后，不立即分配资源，而是根据client发送过来的SYN包计算出一个cookie值，这个cookie值用来存储server返回给client的SYN+ACK数据包中的初始序列号，当client返回第三次握手的ACK包之后进行校验，如果校验成功则server分配资源，建立连接。</p>
</li>
<li><p>SYN proxy代理，作为server与client连接的代理，代替server与client建立三次握手的连接，同时SYN proxy与client建立好了三次握手连接之后，确保是正常的TCP连接，而不是TCP泛洪攻击，那么SYN proxy就与server建立三次握手连接，作为代理（网关？）来连通client与server</p>
</li>
</ul>
<ol start="10">
<li>为什么要四次挥手<br>前两次挥手是为了断开client至server的连接，后两次挥手是为了断开server至client的连接，如果没有第四次挥手，会出现如下状况：</li>
</ol>
<ul>
<li>server发送FIN数据包并携带ACK至client之后直接断开连接，如果client没有收到这个FIN数据包，那么client会一直处于等待关闭状态，这是为了确保TCP协议是面向连接安全有保证锝。</li>
<li>上面解释了为什么不是三次挥手，同理，两次挥手也是不安全的。不能保证server与client都能正确关闭连接释放资源，而不会造成资源浪费。</li>
</ul>
<ol start="11">
<li>四次挥手之后client为什么还要等待2MSL的时间才释放资源关闭连接？ </li>
</ol>
<ul>
<li><p>如果client第四次挥手的确认报文段没有被server接收，那么server便会重发第三次挥手的FIN报文段，因此client要停留2MSL的时长来处理可能会重复收到的报文段。</p>
</li>
<li><p>让之前建立的client-server通信过程中或者是挥手过程中由于网络不通畅产生的滞留报文段失效。如果不等待2MSL，那么建立新连接之后，可能会收到上一次连接的旧报文段，可能会造成混乱。</p>
</li>
</ul>
<ol start="12">
<li>在浏览器输入一个URL按下回车后，其流程是？<br>（1）进行寻址：若浏览器缓存中存有URL的对应IP，则直接查询IP；否则访问DNS（Domain Name System）进行寻址（Domain Name Resolution）。</li>
</ol>
<p>（2） DNS或者URL Cache返回网页服务器的IP地址。</p>
<p>（3）浏览器与网页服务器进行三次握手建立TCP连接。由于是网页浏览服务，故连接到服务器的80端口。</p>
<p>（4）浏览器与服务器建立HTTP会话（Session），接收来自服务器的HTTP数据。</p>
<p>（5）浏览器解析HTTP数据，在本地窗口内渲染并显示网页。</p>
<p>（6）当浏览器页面被关闭时，终止HTTP会话并关闭连接。</p>
<ol start="13">
<li>设计一个可靠的UDP，如何做？<br>“可靠”是指接收端能够将收到的数据情况反馈给发送端。因此完全可以参照可靠的传输协议—–TCP，引入ACK、Flow Cotrol、Congestion Control等模块。可靠的UDP核心在于反馈机制，以下是几种实现方式。<br>（1）最朴素的ACK发送：发送端没发送一个数据包，都需要接收端返回ACK，一旦超时，发送端重新发送数据包，直到该数据包被接收端ACK。该方法效率不高，因为之后的所以数据包都有可能被当前数据包block，并且每次返回ACK增加了overHead。</li>
</ol>
<p>（2）Block/bit map ACK：</p>
<p>发送端发送一批数据包，例如32个，编号是0<code>~</code>31.接收端发回的ACK中用32bit（4byte）的bit map表示收到哪些数据包，发送端再一次性重发所有未被收到的数据包。该方法能够更加充分地利用带宽，在发送端一次性传输更多数据，但缺点是发送、接收端需要更深的buffer来暂存传输的所有数据。</p>
<p>（3）ACK last packet</p>
<p>发送端可以在发送最后一个数据包时要求接收端反馈ACK，并重发丢失的数据包。好处是可以减少由ACK造成的 data overhead，但需要buffer暂存数据。</p>
<p>最佳方法：</p>
<p>事实上，可以结合方法2、3，在每一批数据包的最后一个置位request ACK flag，要求接收端返回bit map ACK。更进一步，可以根据丢包率及延迟，估计网络状态，动态调整bit map大小：网络状态好时，用更大的bit map，即同时发送更多数据。否则减少发送数据量。这种对网络状况的自适应相当于实现了Congestion Control。</p>
<ol start="14">
<li>实时视频会议应用应选择UDP还是TCP？<br>TCP的重传机制特点，会增加延迟，所以不适合此场景。其次视频音频编码本身可以容忍数据出错甚至数据丢失，因此并不需要TCP进行可靠传输。当某一视频帧出现丢包，可以直接跳过。一旦出现网络堵塞情况，发送端应主动丢弃一部分数据，因为即使被发送到接收端也都“过期”了，不会被解码显示。</li>
</ol>
<p>不过即使采用UDP，也需要实现TCP某些模块，例如Flow Control、Congestion Control 来判断接收端的播放情况和网络情况，也需要反馈机制来判断接收端的接收状况。尽管当前场景不需要ACK每个数据包，但接收端可以反馈当前收到最新完整视频帧的序号，这样即使丢包，发送端可以接收端收到最新视频帧为基础，压缩后继的视频。</p>
<ol start="15">
<li>网络中常见的ping 命令是什么协议?<br>“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。</li>
</ol>
<p> ping.exe的原理是向指定的IP地址发送一定长度的数据包，若指定IP地址存在会返回同样大小的数据包，若在特定时间内没有返回，就是“超时”，即指定IP地址不存在。由于ping使用的ICMP协议，有些防火墙软件会平米ICMP协议，所以ping结果只能作为参考，ping不通不一定代表对方IP不存在。</p>
<p>ICMP协议: ICMP是“Internet Control Message Protocol”（Internet控制消息协议）的缩写。它是<br>TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p>
<ol start="16">
<li>如何编写Socket套接字？<br>如果你要编写的是一个服务程序，那么先调用socket()创建一个套接字，调用bind()绑定IP地址和端口，然后启动一个死循环，循环中调用accept()接受连接。对于每个接受的连接，可以启动多线程方式进行处理，在线程中调用send()、recv()发送和接收数据。<br>如果你要编写的是一个客户端程序，那么就简单多了。先调用socket()创建一个套接字，然后调用connect()连接服务器，之后就是调用send()、recv()发送和接收数据了。</li>
</ol>
<p>服务器端程序编写：</p>
<ul>
<li>调用 ServerSocket(int port) 创建一个服务器端套接字，并绑定到指定端口上。</li>
<li>调用 accept()，监听连接请求，则接收连接，返回通信套接字。</li>
<li>调用Socket类的 getOutStream() 和 getInputStream()获取输出流和输入流，开始网络数据的发送和接收。</li>
<li>关闭通信套接字 Socket.close()。</li>
</ul>
<p>客户端程序编写：</p>
<ul>
<li>调用 Socket() 创建一个流套接字，并连接到服务器端。</li>
<li>调用Socket类的 getOutputStream()和 getInputStream()获取输出流和输入流，开始网络数据的发送和接收。</li>
<li>关闭通信套接字 Socket.close()。</li>
</ul>
<ol start="17">
<li>端口概念<br>在网络技术中，端口（Port）大致有两种意思：</li>
</ol>
<p>一是物理意义上的端口，比如，ADSL MODEM、集线器、交换机、路由器用于连接其他网络设备的接口；<br>二是逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围为0～65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口。</p>
<p>下面将介绍两种常见的逻辑分类：</p>
<p>（1）按端口号分布划分</p>
<ul>
<li><p>知名端口（Well-Known Ports）：即众所周知的端口号，范围为0～1023，这些端口号一般固定分配给一些服务。<br>比如21端口分配给FTP服务，25端口分配给SMTP（简单邮件传输协议）服务，80端口分配给HTTP服务。</p>
</li>
<li><p>动态端口（Dynamic Ports）：范围为1024～65535，这些端口号一般不固定分配给某个服务，也就是说许多服务都可以使用这些端口。只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。比如1024端口就是<br>分配给第一个向系统发出申请的程序。在关闭程序进程后，就会释放所占用的端口号。<br>（2）按协议类型划分</p>
</li>
</ul>
<p>按协议类型划分，可以分为TCP、UDP、IP和ICMP（Internet控制消息协议）等端口。下面主要介绍TCP和UDP端口：</p>
<ul>
<li><p>TCP端口：即传输控制协议端口，需要在客户端和服务器之间建立连接，这样可以提供可靠的数据传输。常见的包括FTP服务的21端口，Telnet服务的23端口，SMTP服务的25端口，以及HTTP服务的80端口等等。</p>
</li>
<li><p>UDP端口：即用户数据包协议端口，无须在客户端和服务器之间建立连接，安全性得不到保障。常见的有DNS服务的53端口，SNMP（简单网络管理协议）服务的161端口，QQ使用的8000和4000端口等等。</p>
</li>
</ul>

        <h3 id="参考资料">
          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3>
      <ul>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.csdn.net/scuzoutao/article/details/81774100">TCP三次握手四次挥手总结（流程、常见问题、会发生的攻击、防范方法）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38950316/article/details/81087809">TCP的三次握手与四次挥手理解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.csdn.net/ITermeng/article/details/77973279?locationNum=7&fps=1">深入浅出之 TCP协议（三次握手与四次挥手、超时重发、流量控制、拥塞控制、与UDP区别）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://focusss.github.io">大湾区码仔驰名商标</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">https://focusss.github.io/2019/04/11/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://focusss.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2019/04/11/TCP%E9%95%BF%E9%93%BE%E6%8E%A5%E5%8F%8A%E7%9F%AD%E9%93%BE%E6%8E%A5/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">TCP长链接及短链接</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2019/04/11/BIO%E3%80%81NIO%E5%92%8CAIO/"><span class="paginator-prev__text">BIO、NIO和AIO</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">
          简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">
          特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">
          优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%88%E5%BA%8F%E5%88%97%E5%8F%B7-%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">
          可靠传输（序列号+确认应答）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94ACK%EF%BC%88Positive-Acknowledgment%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">
          确认应答ACK（Positive Acknowledgment）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="toc-number">4.2.</span> <span class="toc-text">
          序列号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%8F%91%E8%B6%85%E6%97%B6"><span class="toc-number">5.</span> <span class="toc-text">
          重发超时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">
          连接管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%91%A2"><span class="toc-number">6.1.</span> <span class="toc-text">
          为什么建立连接是三次握手，而关闭连接却是四次挥手呢</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%8E%A7%E5%88%B6%EF%BC%88Flow-Control%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">
          流控制（Flow Control）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.1.</span> <span class="toc-text">
          滑动窗口协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E6%B5%81%E6%8E%A7%E5%88%B6"><span class="toc-number">7.2.</span> <span class="toc-text">
          解释流控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Zero-Window"><span class="toc-number">7.3.</span> <span class="toc-text">
          Zero Window</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%88Congestion-Control%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">
          拥塞控制（Congestion Control）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8%EF%BC%88Slow-Start%EF%BC%89"><span class="toc-number">8.1.</span> <span class="toc-text">
          慢启动（Slow Start）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95%EF%BC%88Congestion-Avoidance%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">
          拥塞避免算法（Congestion Avoidance）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E7%8A%B6%E6%80%81%E6%97%B6%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">
          拥塞状态时的算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95%EF%BC%88Fast-Recovery%EF%BC%89"><span class="toc-number">8.4.</span> <span class="toc-text">
          快速恢复算法（Fast Recovery）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">
          TCP和UDP的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%EF%BC%88User-Datagram-Protocol%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">
          UDP（User Datagram Protocol）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">9.2.</span> <span class="toc-text">
          区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text">
          常见问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">11.</span> <span class="toc-text">
          参考资料</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/headImg.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">平安大赚 财丁兴旺</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">74</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">21</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">29</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>大湾区码仔驰名商标</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script></div><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>